<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DEPLOYMENT_GUIDE_WALLET_CREATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DEPLOYMENT_GUIDE_WALLET_CREATION.md" />
              <option name="updatedContent" value="# Guide de Déploiement - Création de Portefeuille Sniperoo&#10;&#10;##  Étapes de Déploiement&#10;&#10;### 1. Redéployer l'API sur Railway&#10;&#10;**Option A : Via Railway Dashboard**&#10;1. Allez sur https://railway.app/dashboard&#10;2. Sélectionnez votre projet **api-production-5998**&#10;3. Cliquez sur le bouton **Redeploy**&#10;4. Attendez que le déploiement se termine (statut ✅ Successful)&#10;&#10;**Option B : Via Git Push**&#10;```bash&#10;cd /path/to/crm-ubicos&#10;git add .&#10;git commit -m &quot;Fix: wallet creation with proper encryption key generation&quot;&#10;git push railway main&#10;```&#10;&#10;### 2. Vérifier les Variables d'Environnement&#10;&#10;Allez dans **Railway Dashboard** → **API Service** → **Variables**&#10;&#10;Assurez-vous que ces variables sont définies :&#10;&#10;```&#10;DATABASE_URL=postgresql://...&#10;REDIS_HOST=...&#10;REDIS_PORT=...&#10;JWT_SECRET=your-secret-key&#10;JWT_REFRESH_SECRET=your-refresh-secret&#10;SNIPEROO_API_URL=https://api.sniperoo.io&#10;SNIPEROO_API_KEY=&lt;VOTRE_CLÉ_API_VALIDE&gt;&#10;SNIPEROO_WS_URL=wss://ws.sniperoo.io&#10;FRONTEND_URL=https://web-production-1beed.up.railway.app&#10;```&#10;&#10;**⚠️ IMPORTANT**: Sans `SNIPEROO_API_KEY` valide, la création de portefeuille échouera toujours.&#10;&#10;### 3. Vérifier les Logs&#10;&#10;Une fois redéployé, allez dans **Logs** et cherchez :&#10;&#10;**✅ Succès**:&#10;```&#10;[SniperooService] SniperooService initialized with API URL: https://api.sniperoo.io&#10;[SniperooService] Wallet API Response: {...wallet data...}&#10;[SniperooService] Wallet created: wallet_xxxxx&#10;```&#10;&#10;**❌ Erreur (besoin d'action)**:&#10;```&#10;[SniperooService] SNIPEROO_API_KEY is not configured&#10;[SniperooService] Response data: {&quot;error&quot;: &quot;Unauthorized&quot;}&#10;```&#10;&#10;### 4. Tester la Création de Portefeuille&#10;&#10;**Via l'Interface Web**:&#10;1. Ouvrez https://web-production-1beed.up.railway.app&#10;2. Connectez-vous&#10;3. Allez dans **Dashboard** → **Wallets**&#10;4. Cliquez sur **Create Wallet**&#10;5. Entrez un nom (ex: &quot;Mon Portefeuille&quot;)&#10;6. Cliquez sur **Create Wallet**&#10;&#10;**Résultat Attendu**:&#10;- ✅ Le portefeuille est créé avec succès&#10;- ✅ Vous voyez l'ID du portefeuille&#10;- ✅ La clé publique est affichée&#10;- ✅ Le solde initial est 0 SOL&#10;&#10;**Via cURL** (pour debug):&#10;```bash&#10;# Récupérez votre token JWT d'abord&#10;TOKEN=&quot;votre-token-jwt&quot;&#10;&#10;# Créez un portefeuille&#10;curl -X POST https://api-production-5998.up.railway.app/api/wallets \&#10;  -H &quot;Authorization: Bearer $TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;name&quot;: &quot;Test Wallet&quot;}'&#10;&#10;# Réponse attendue:&#10;# {&#10;#   &quot;id&quot;: &quot;wallet_xxx&quot;,&#10;#   &quot;name&quot;: &quot;Test Wallet&quot;,&#10;#   &quot;publicKey&quot;: &quot;So1...&quot;,&#10;#   &quot;balance&quot;: 0,&#10;#   &quot;isActive&quot;: true,&#10;#   &quot;createdAt&quot;: &quot;2025-11-09T...&quot;&#10;# }&#10;```&#10;&#10;##  Dépannage&#10;&#10;### Erreur: &quot;Cannot read properties of undefined&quot;&#10;&#10;**Cause**: La réponse Sniperoo n'a pas la structure attendue&#10;&#10;**Solution**:&#10;1. Vérifiez que `SNIPEROO_API_KEY` est correct&#10;2. Vérifiez que `SNIPEROO_API_URL` est `https://api.sniperoo.io` (pas `.app` ou `.com`)&#10;3. Contactez le support Sniperoo pour confirmer la structure de réponse&#10;&#10;### Erreur: &quot;Request failed with status code 400&quot;&#10;&#10;**Cause**: Mauvais format de requête&#10;&#10;**Solutions**:&#10;1. Vérifiez que le format de la requête est correct : `{ &quot;name&quot;: &quot;string&quot; }`&#10;2. Vérifiez que votre clé API a les permissions pour créer des portefeuilles&#10;3. Contactez Sniperoo pour vérifier les spécifications&#10;&#10;### Erreur: &quot;Request failed with status code 401&quot;&#10;&#10;**Cause**: Clé API invalide ou expirée&#10;&#10;**Solutions**:&#10;1. Générez une nouvelle clé API depuis le dashboard Sniperoo&#10;2. Mettez à jour la variable `SNIPEROO_API_KEY` sur Railway&#10;3. Redéployez l'application&#10;&#10;### Erreur: &quot;Timeout after 30000ms&quot;&#10;&#10;**Cause**: L'API Sniperoo répond lentement ou n'est pas accessible&#10;&#10;**Solutions**:&#10;1. Vérifiez votre connexion Internet&#10;2. Vérifiez que le pare-feu/VPN ne bloque pas `https://api.sniperoo.io`&#10;3. Augmentez le timeout dans `sniperoo.service.ts` si nécessaire&#10;&#10;##  Vérification Post-Déploiement&#10;&#10;### Checklist&#10;&#10;- [ ] Redéploiement terminé avec succès&#10;- [ ] `SNIPEROO_API_KEY` est configurée et valide&#10;- [ ] Les logs ne montrent pas d'erreur 401 ou 404&#10;- [ ] Un test de création de portefeuille réussit&#10;- [ ] La clé privée est chiffrée et stockée&#10;&#10;### Cas de Test&#10;&#10;1. **Créer un portefeuille**&#10;   - Entrée: `{ &quot;name&quot;: &quot;Test Wallet&quot; }`&#10;   - Résultat attendu: Portefeuille créé avec ID unique&#10;&#10;2. **Importer un portefeuille**&#10;   - Entrée: `{ &quot;name&quot;: &quot;Imported&quot;, &quot;privateKey&quot;: &quot;...&quot; }`&#10;   - Résultat attendu: Portefeuille importé avec solde&#10;&#10;3. **Récupérer les portefeuilles**&#10;   - Résultat attendu: Liste des portefeuilles de l'utilisateur&#10;&#10;##  Backup de Configuration&#10;&#10;Avant de faire des changements, sauvegardez vos variables d'environnement :&#10;&#10;```bash&#10;# Exporter les variables (pour votre référence personnelle)&#10;SNIPEROO_API_KEY=&quot;votre-clé-api&quot;&#10;SNIPEROO_API_URL=&quot;https://api.sniperoo.io&quot;&#10;JWT_SECRET=&quot;votre-secret-jwt&quot;&#10;&#10;# Conservez ces valeurs en lieu sûr&#10;```&#10;&#10;##  Notes Importantes&#10;&#10;1. **Chiffrement des Clés Privées**: Les clés privées sont chiffrées avec AES-256-GCM&#10;2. **Sécurité**: La clé de déchiffrement est dérivée de l'ID utilisateur et du JWT_SECRET&#10;3. **Retry Logic**: En cas d'erreur, le service retry automatiquement (3 tentatives avec backoff exponentiel)&#10;4. **Logging**: Tous les appels à Sniperoo sont loggés pour faciliter le debug&#10;&#10;##  Support&#10;&#10;Si vous rencontrez encore des erreurs après avoir suivi ce guide :&#10;&#10;1. Vérifiez les logs de Railway&#10;2. Consultez la documentation Sniperoo: https://sniperoo.redocly.app&#10;3. Contactez le support Sniperoo avec votre clé API&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_MAP_NOT_A_FUNCTION_ERROR.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_MAP_NOT_A_FUNCTION_ERROR.md" />
              <option name="updatedContent" value="# Fix: TypeError - g.map is not a function&#10;&#10;##  Problème Identifié&#10;&#10;L'erreur `TypeError: g.map is not a function` se produisait car `wallets` n'était pas un tableau et le composant tentait d'appeler `.map()` dessus.&#10;&#10;```javascript&#10;// Error trace&#10;at g (page-fb9a91042dba4ed1.js:6:4374)&#10;  // g.map is not a function&#10;```&#10;&#10;### Causes Possibles&#10;1. `walletAPI.fetchWallets()` retournait une réponse mal formatée&#10;2. `response.data` n'était pas un tableau directement&#10;3. Pas de gestion des erreurs en cas d'échec de la requête&#10;&#10;## ✅ Solutions Implémentées&#10;&#10;### 1. **wallets.ts - Gestion Flexible des Formats de Réponse**&#10;&#10;```typescript&#10;async fetchWallets(): Promise&lt;Wallet[]&gt; {&#10;  try {&#10;    const response = await this.client.get&lt;Wallet[] | { wallets: Wallet[] } | any&gt;('/');&#10;    &#10;    // Handle different response formats&#10;    if (Array.isArray(response.data)) {&#10;      return response.data;&#10;    }&#10;    &#10;    // If wrapped in a wallets property&#10;    if (response.data &amp;&amp; Array.isArray(response.data.wallets)) {&#10;      return response.data.wallets;&#10;    }&#10;    &#10;    // If wrapped in a data property&#10;    if (response.data &amp;&amp; Array.isArray(response.data.data)) {&#10;      return response.data.data;&#10;    }&#10;    &#10;    // Fallback to empty array if not found&#10;    console.warn('Unexpected wallet response format:', response.data);&#10;    return [];&#10;  } catch (error) {&#10;    console.error('Error fetching wallets:', error);&#10;    return [];&#10;  }&#10;}&#10;```&#10;&#10;**Bénéfices** :&#10;- ✅ Gère plusieurs formats de réponse&#10;- ✅ Retourne toujours un tableau&#10;- ✅ Logging en cas de format inattendu&#10;- ✅ Gère les erreurs réseau&#10;&#10;### 2. **dashboard/wallets/page.tsx - Validation du Type**&#10;&#10;```typescript&#10;useEffect(() =&gt; {&#10;  const loadWallets = async () =&gt; {&#10;    try {&#10;      setIsLoadingWallets(true);&#10;      const fetchedWallets = await walletAPI.fetchWallets();&#10;      // Ensure wallets is always an array&#10;      setWallets(Array.isArray(fetchedWallets) ? fetchedWallets : []);&#10;    } catch (err) {&#10;      console.error('Error fetching wallets:', err);&#10;      setWallets([]);&#10;    } finally {&#10;      setIsLoadingWallets(false);&#10;    }&#10;  };&#10;&#10;  if (isAuthenticated &amp;&amp; user) {&#10;    loadWallets();&#10;  }&#10;}, [isAuthenticated, user]);&#10;```&#10;&#10;**Bénéfices** :&#10;- ✅ Vérifie que `fetchedWallets` est un tableau&#10;- ✅ Fallback à tableau vide en cas d'erreur&#10;- ✅ Capture les erreurs de chargement&#10;&#10;### 3. **wallets/page.tsx - Gestion d'Erreur pour useWallets()**&#10;&#10;```typescript&#10;const { data: wallets = [], isLoading, error } = useWallets();&#10;&#10;// Ensure wallets is always an array&#10;&lt;WalletList wallets={Array.isArray(wallets) ? wallets : []} isLoading={isLoading} /&gt;&#10;&#10;// Display error state&#10;{error &amp;&amp; (&#10;  &lt;div className=&quot;bg-red-50 border border-red-200 rounded-lg p-4&quot;&gt;&#10;    &lt;p className=&quot;text-red-800&quot;&gt;Error loading wallets. Please try again.&lt;/p&gt;&#10;  &lt;/div&gt;&#10;)}&#10;```&#10;&#10;**Bénéfices** :&#10;- ✅ Valide le type de `wallets`&#10;- ✅ Affiche les erreurs à l'utilisateur&#10;- ✅ Fallback par défaut à `[]`&#10;&#10;### 4. **wallets/[id]/page.tsx - Gestion Sûre du walletId**&#10;&#10;```typescript&#10;const walletId = Array.isArray(params.id) ? params.id[0] : (params.id as string);&#10;&#10;if (!walletId) {&#10;  return (&#10;    &lt;div className=&quot;container mx-auto p-6&quot;&gt;&#10;      &lt;div className=&quot;text-center py-12&quot;&gt;&#10;        &lt;p className=&quot;text-red-500 mb-4&quot;&gt;Invalid wallet ID&lt;/p&gt;&#10;        &lt;Link href=&quot;/dashboard/wallets&quot;&gt;&#10;          &lt;Button&gt;Back to Wallets&lt;/Button&gt;&#10;        &lt;/Link&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;```&#10;&#10;**Bénéfices** :&#10;- ✅ Gère le cas où `params.id` est un tableau&#10;- ✅ Valide le walletId avant utilisation&#10;- ✅ Affiche une erreur appropriée&#10;&#10;##  Flow de Sécurité&#10;&#10;```&#10;1. fetchWallets() appelée&#10;   ↓&#10;2. Réponse reçue (format variable)&#10;   ↓&#10;3. Validation du format (4 formats possibles)&#10;   ↓&#10;4. Retour tableau (garanti)&#10;   ↓&#10;5. Stockage dans état React&#10;   ↓&#10;6. .map() appelée sur tableau valide&#10;   ↓&#10;7. ✅ Pas d'erreur &quot;g.map is not a function&quot;&#10;```&#10;&#10;## ✅ Résultats&#10;&#10;**Avant** :&#10;```&#10;Wallets fetch&#10;  ↓&#10;Réponse reçue (format imprévu)&#10;  ↓&#10;setWallets(réponse)&#10;  ↓&#10;{wallets.map(...)}&#10;  ↓&#10;❌ TypeError: g.map is not a function&#10;```&#10;&#10;**Après** :&#10;```&#10;Wallets fetch&#10;  ↓&#10;Réponse reçue (format imprévu)&#10;  ↓&#10;Validation et normalisation à tableau&#10;  ↓&#10;setWallets([...])&#10;  ↓&#10;{wallets.map(...)}&#10;  ↓&#10;✅ Fonctionne correctement&#10;```&#10;&#10;##  Test&#10;&#10;1. **Page dashbaord/wallets** :&#10;   - Doit charger et afficher les portefeuilles&#10;   - Pas d'erreur &quot;g.map is not a function&quot;&#10;   - Fallback à tableau vide si erreur&#10;&#10;2. **Page wallets** :&#10;   - Doit utiliser useWallets() query&#10;   - Affiche les portefeuilles&#10;   - Affiche le message d'erreur si besoin&#10;&#10;3. **Page wallets/[id]** :&#10;   - Doit gérer les URLs dynamiques&#10;   - Affiche les détails correctement&#10;   - Gère les IDs invalides&#10;&#10;##  Fichiers Modifiés&#10;&#10;1. ✅ `apps/web/src/lib/api/wallets.ts` - Gestion multi-format&#10;2. ✅ `apps/web/src/app/(dashboard)/dashboard/wallets/page.tsx` - Validation&#10;3. ✅ `apps/web/src/app/(dashboard)/wallets/page.tsx` - Gestion d'erreur&#10;4. ✅ `apps/web/src/app/(dashboard)/wallets/[id]/page.tsx` - Gestion du walletId&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_SNIPEROO_RESPONSE_FORMAT.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_SNIPEROO_RESPONSE_FORMAT.md" />
              <option name="updatedContent" value="# Fix: Sniperoo API Response Format Handling&#10;&#10;##  Problème Identifié&#10;&#10;L'API Sniperoo retourne une réponse avec une structure différente de celle initialement prévue :&#10;&#10;### Réponse Réelle de Sniperoo&#10;```json&#10;{&#10;  &quot;hidden&quot;: false,&#10;  &quot;id&quot;: 21555,&#10;  &quot;name&quot;: &quot;tets&quot;,&#10;  &quot;userId&quot;: 15578,&#10;  &quot;walletAddress&quot;: &quot;9T3hUKCycSMpCRaGd4JtZvBNGLi8AiDeYr79rp49qKKb&quot;,&#10;  &quot;walletPk&quot;: &quot;ab4de4f51053faf0cbdeb28adb3d91ad:8c2972e36c961af9a6cfe8ecf99276a23c99063875670709108564baf5bc2f691...&quot;&#10;}&#10;```&#10;&#10;### Champs Mappés&#10;- `id` → ID du portefeuille Sniperoo&#10;- `walletAddress` → Clé publique Solana&#10;- `walletPk` → Clé privée (déjà chiffrée par Sniperoo)&#10;&#10;## ✅ Solutions Implémentées&#10;&#10;### 1. **sniperoo.service.ts - Gestion Multi-Format**&#10;&#10;Ajout de la gestion flexible pour plusieurs formats de réponse :&#10;&#10;```typescript&#10;// Format Sniperoo réel: { id, walletAddress, walletPk, ... }&#10;if (walletData.id &amp;&amp; walletData.walletAddress &amp;&amp; walletData.walletPk) {&#10;  return {&#10;    wallet: {&#10;      id: walletData.id.toString(),&#10;      publicKey: walletData.walletAddress,&#10;      balance: 0,&#10;      createdAt: new Date().toISOString(),&#10;    },&#10;    privateKey: walletData.walletPk,&#10;  };&#10;}&#10;&#10;// Format imbriqué: { wallet: {...}, privateKey: &quot;...&quot; }&#10;if (walletData.wallet &amp;&amp; walletData.wallet.id) {&#10;  return { wallet: walletData.wallet, privateKey: walletData.privateKey };&#10;}&#10;&#10;// Format plat: { id, publicKey, privateKey, ... }&#10;if (walletData.id &amp;&amp; walletData.privateKey) {&#10;  return {&#10;    wallet: {&#10;      id: walletData.id.toString(),&#10;      publicKey: walletData.publicKey || walletData.address || '',&#10;      balance: walletData.balance || 0,&#10;    },&#10;    privateKey: walletData.privateKey,&#10;  };&#10;}&#10;```&#10;&#10;### 2. **wallets.service.ts - Stockage Correct de la Clé Privée**&#10;&#10;**Pour `create()`** - Stockage direct de `walletPk` de Sniperoo :&#10;```typescript&#10;// Sniperoo retourne walletPk qui est déjà chiffré, le stocker directement&#10;encryptedPrivateKey: sniperooWallet.privateKey&#10;```&#10;&#10;**Pourquoi?**&#10;- Sniperoo chiffre déjà `walletPk`&#10;- Pas besoin de le re-chiffrer&#10;- Stockage direct économise du traitement et évite la double-encryption&#10;&#10;**Pour `import()`** - Chiffrement de la clé fournie par l'utilisateur :&#10;```typescript&#10;// Pour les portefeuilles importés, chiffrer la clé fournie par l'utilisateur&#10;const encryptionKey = this.generateEncryptionKey(userId);&#10;const encryptedKey = this.encryptPrivateKey(importWalletDto.privateKey, encryptionKey);&#10;encryptedPrivateKey: encryptedKey&#10;```&#10;&#10;##  Flux de Traitement&#10;&#10;### Création de Portefeuille&#10;```&#10;Frontend: POST /api/wallets { &quot;name&quot;: &quot;Mon Portefeuille&quot; }&#10;  ↓&#10;Backend: walletAPI.createWallet()&#10;  ↓&#10;Sniperoo: POST /user/wallets { &quot;name&quot;: &quot;Mon Portefeuille&quot; }&#10;  ↓&#10;Réponse Sniperoo:&#10;  {&#10;    id: 21555,&#10;    walletAddress: &quot;9T3h...&quot;,&#10;    walletPk: &quot;ab4de4...&quot; (déjà chiffré)&#10;  }&#10;  ↓&#10;Backend: Mappage vers SniperooCreateWalletResponse&#10;  {&#10;    wallet: { id: &quot;21555&quot;, publicKey: &quot;9T3h...&quot;, balance: 0 },&#10;    privateKey: &quot;ab4de...&quot; (déjà chiffré)&#10;  }&#10;  ↓&#10;Stockage DB:&#10;  {&#10;    sniperooWalletId: &quot;21555&quot;,&#10;    publicKey: &quot;9T3h...&quot;,&#10;    encryptedPrivateKey: &quot;ab4de...&quot; (stocké tel quel)&#10;  }&#10;```&#10;&#10;### Import de Portefeuille&#10;```&#10;Frontend: POST /api/wallets/import &#10;  { &quot;name&quot;: &quot;Importé&quot;, &quot;privateKey&quot;: &quot;privateKey...&quot; }&#10;  ↓&#10;Backend: Chiffrement avec clé utilisateur&#10;  encryptionKey = SHA256(userId + &quot;:&quot; + JWT_SECRET)&#10;  encryptedPrivateKey = AES-256-GCM(privateKey, encryptionKey)&#10;  ↓&#10;Sniperoo: POST /user/wallets/import&#10;  { &quot;name&quot;: &quot;Importé&quot;, &quot;privateKey&quot;: &quot;privateKey...&quot; }&#10;  ↓&#10;Stockage DB:&#10;  {&#10;    publicKey: &quot;Solana address&quot;,&#10;    encryptedPrivateKey: &quot;encrypted_by_us&quot; (double-layer security)&#10;  }&#10;```&#10;&#10;##  Sécurité&#10;&#10;### Portefeuilles Créés (via Sniperoo)&#10;- ✅ Clé privée chiffrée par Sniperoo&#10;- ✅ Double protection : Sniperoo + DB&#10;- ✅ Accès sécurisé via `SniperooService`&#10;&#10;### Portefeuilles Importés (par l'utilisateur)&#10;- ✅ Clé privée chiffrée par nous avec AES-256-GCM&#10;- ✅ Clé dérivée de l'ID utilisateur + JWT_SECRET&#10;- ✅ Salt aléatoire pour chaque clé&#10;- ✅ Authentication tag pour l'intégrité&#10;&#10;## ✅ Erreurs Attendues Résolues&#10;&#10;**Avant:**&#10;- ❌ &quot;Cannot read properties of undefined (reading 'wallet.id')&quot;&#10;- ❌ &quot;Unexpected response format&quot;&#10;&#10;**Après:**&#10;- ✅ Réponse Sniperoo correctement parsée&#10;- ✅ Clé privée correctement stockée&#10;- ✅ Portefeuille créé et retourné à l'utilisateur&#10;&#10;##  Test&#10;&#10;Pour tester manuellement :&#10;&#10;```bash&#10;# 1. Obtenir un token JWT&#10;TOKEN=&quot;votre-jwt-token&quot;&#10;&#10;# 2. Créer un portefeuille&#10;curl -X POST https://api-production-5998.up.railway.app/api/wallets \&#10;  -H &quot;Authorization: Bearer $TOKEN&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;name&quot;: &quot;Mon Portefeuille&quot;}'&#10;&#10;# Réponse attendue:&#10;# {&#10;#   &quot;id&quot;: &quot;wallet_local_db_id&quot;,&#10;#   &quot;name&quot;: &quot;Mon Portefeuille&quot;,&#10;#   &quot;publicKey&quot;: &quot;9T3hUKCycSMpCRaGd4JtZvBNGLi8AiDeYr79rp49qKKb&quot;,&#10;#   &quot;balance&quot;: 0,&#10;#   &quot;isActive&quot;: true,&#10;#   &quot;createdAt&quot;: &quot;2025-11-09T...&quot;&#10;# }&#10;```&#10;&#10;##  Fichiers Modifiés&#10;&#10;1. ✅ `apps/api/src/sniperoo/sniperoo.service.ts` - Gestion multi-format de réponse&#10;2. ✅ `apps/api/src/wallets/wallets.service.ts` - Stockage correct des clés chiffrées&#10;3. ✅ `apps/api/src/wallets/wallets.service.spec.ts` - Tests mis à jour&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FIX_WALLET_CREATION_ERRORS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FIX_WALLET_CREATION_ERRORS.md" />
              <option name="updatedContent" value="# Diagnostic et Solution - Erreur 400 Sniperoo&#10;&#10;##  Problèmes Identifiés&#10;&#10;### Erreur 1: &quot;Cannot read properties of undefined (reading 'id')&quot;&#10;**Cause**: La réponse de Sniperoo n'a pas la structure attendue `{ wallet: {...}, privateKey: &quot;...&quot; }`&#10;&#10;**Solution**: Ajout de gestion flexible des formats de réponse dans `createWallet()` :&#10;```typescript&#10;// Handle different response formats&#10;if (walletData.wallet) { ... }&#10;if (walletData.id &amp;&amp; walletData.privateKey) { ... }&#10;```&#10;&#10;### Erreur 2: &quot;Request failed with status code 400&quot; (Bad Request)&#10;**Cause**: Probablement due à une clé API manquante ou invalide&#10;&#10;**Solutions Appliquées**:&#10;1. Amélioration du logging pour voir la réponse d'erreur réelle&#10;2. Vérification que la clé API est correctement passée dans les en-têtes&#10;&#10;### Erreur 3: &quot;Cannot read properties of undefined (reading 'password')&quot;&#10;**Cause**: Le contrôleur tentait d'accéder à `@CurrentUser('password')` qui n'existe pas dans le JWT&#10;&#10;**Solution**: &#10;- ✅ Suppression du paramètre `password` du contrôleur&#10;- ✅ Génération d'une clé de déchiffrement déterministe basée sur `userId` et `JWT_SECRET`&#10;- ✅ Mise à jour de `WalletsService` pour utiliser cette clé générée&#10;&#10;## ✅ Changements Effectués&#10;&#10;### 1. wallets.controller.ts&#10;```typescript&#10;// Avant&#10;create(&#10;  @CurrentUser('id') userId: string,&#10;  @CurrentUser('password') password: string,&#10;  @Body() createWalletDto: CreateWalletDto,&#10;) {&#10;  return this.walletsService.create(userId, createWalletDto, password);&#10;}&#10;&#10;// Après&#10;create(&#10;  @CurrentUser('id') userId: string,&#10;  @Body() createWalletDto: CreateWalletDto,&#10;) {&#10;  return this.walletsService.create(userId, createWalletDto);&#10;}&#10;```&#10;&#10;### 2. wallets.service.ts&#10;```typescript&#10;// Avant&#10;async create(userId: string, createWalletDto: CreateWalletDto, userPassword: string) {&#10;  const encryptedKey = this.encryptPrivateKey(sniperooWallet.privateKey, userPassword);&#10;}&#10;&#10;// Après&#10;async create(userId: string, createWalletDto: CreateWalletDto) {&#10;  const encryptionKey = this.generateEncryptionKey(userId);&#10;  const encryptedKey = this.encryptPrivateKey(sniperooWallet.privateKey, encryptionKey);&#10;}&#10;&#10;// Nouvelle méthode&#10;private generateEncryptionKey(userId: string): string {&#10;  const secret = this.configService.get&lt;string&gt;('JWT_SECRET') || 'default-secret';&#10;  return crypto.createHash('sha256').update(`${userId}:${secret}`).digest('hex');&#10;}&#10;```&#10;&#10;### 3. sniperoo.service.ts&#10;Amélioré le logging pour afficher la réponse réelle :&#10;```typescript&#10;this.logger.log(`Wallet API Response:`, JSON.stringify(response.data));&#10;// Gestion de plusieurs formats de réponse&#10;```&#10;&#10;##  Prochaines Étapes&#10;&#10;### 1. Vérifier que SNIPEROO_API_KEY est configurée&#10;Sur Railway, vérifiez que :&#10;- `SNIPEROO_API_URL=https://api.sniperoo.io`&#10;- `SNIPEROO_API_KEY=&lt;clé-valide&gt;`&#10;- `SNIPEROO_WS_URL=wss://ws.sniperoo.io`&#10;&#10;### 2. Redéployer l'application API&#10;```bash&#10;# Sur Railway, cliquez sur &quot;Redeploy&quot;&#10;```&#10;&#10;### 3. Tester la création de portefeuille&#10;Vérifiez les logs pour voir :&#10;```&#10;✅ Wallet API Response: {...}&#10;✅ Wallet created: &lt;wallet-id&gt;&#10;```&#10;&#10;### 4. Si erreur 400 persiste&#10;Les logs afficheront maintenant la réponse d'erreur réelle :&#10;```&#10;ERROR [SniperooService] Response data: { error: &quot;...&quot;, message: &quot;...&quot; }&#10;```&#10;&#10;Cela permettra d'identifier le problème exact.&#10;&#10;##  Sécurité - Génération de Clé de Déchiffrement&#10;&#10;La nouvelle approche utilise:&#10;- **Base**: L'ID utilisateur unique&#10;- **Secret**: `JWT_SECRET` de la configuration&#10;- **Algorithme**: SHA-256&#10;&#10;Formule: `encryptionKey = SHA256(userId + &quot;:&quot; + JWT_SECRET)`&#10;&#10;**Avantages**:&#10;- ✅ Pas de mot de passe stocké/transmis&#10;- ✅ Clé unique par utilisateur&#10;- ✅ Déterministe (même clé générée à chaque fois)&#10;- ✅ Securisée (SHA-256)&#10;&#10;**Limitation**:&#10;- ⚠️ Si l'utilisateur oublie son JWT_SECRET, les portefeuilles ne pourront pas être déchiffrés&#10;  - **Solution Future**: Implémentation d'une rotation de clés ou d'une fonction de récupération&#10;&#10;##  Fichiers Modifiés&#10;&#10;1. ✅ `apps/api/src/wallets/wallets.controller.ts` - Suppression du paramètre password&#10;2. ✅ `apps/api/src/wallets/wallets.service.ts` - Génération déterministe de clé&#10;3. ✅ `apps/api/src/sniperoo/sniperoo.service.ts` - Meilleur logging d'erreur&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/RAILWAY_ENVIRONMENT_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/RAILWAY_ENVIRONMENT_SETUP.md" />
              <option name="updatedContent" value="# Configuration Railway - Variables d'Environnement&#10;&#10;##  Configuration Requise pour le Déploiement&#10;&#10;Pour que la création de portefeuilles fonctionne correctement sur Railway, vous devez configurer les variables d'environnement suivantes dans votre application API.&#10;&#10;### Variables Essentielles&#10;&#10;```&#10;SNIPEROO_API_URL=https://api.sniperoo.io&#10;SNIPEROO_API_KEY=&lt;votre-clé-api-sniperoo&gt;&#10;SNIPEROO_WS_URL=wss://ws.sniperoo.io&#10;```&#10;&#10;##  Checklist de Configuration&#10;&#10;- [ ] **SNIPEROO_API_KEY** : Obtenir une clé API valide depuis https://sniperoo.io&#10;- [ ] **SNIPEROO_API_URL** : Vérifier que l'URL est `https://api.sniperoo.io`&#10;- [ ] **SNIPEROO_WS_URL** : Configurer `wss://ws.sniperoo.io` pour WebSocket&#10;&#10;### Obtenir votre clé API Sniperoo&#10;&#10;1. Accédez au dashboard Sniperoo : https://dashboard.sniperoo.io&#10;2. Allez dans **Settings** → **API Keys**&#10;3. Créez une nouvelle clé API&#10;4. Copiez la clé complète&#10;5. Assurez-vous que la clé a les permissions :&#10;   - ✅ Create Wallets&#10;   - ✅ Import Wallets&#10;   - ✅ Read Wallets&#10;   - ✅ Delete Wallets&#10;   - ✅ Execute Trades&#10;&#10;##  Déploiement sur Railway&#10;&#10;### Étape 1 : Accédez à votre Projet Railway&#10;1. Allez sur https://railway.app/dashboard&#10;2. Sélectionnez votre projet CRM-UBICOS&#10;3. Cliquez sur le service **API**&#10;&#10;### Étape 2 : Configurez les Variables d'Environnement&#10;1. Allez dans l'onglet **Variables**&#10;2. Cliquez sur **+ New Variable**&#10;3. Ajoutez chaque variable :&#10;&#10;**Variable 1 : SNIPEROO_API_URL**&#10;- Clé : `SNIPEROO_API_URL`&#10;- Valeur : `https://api.sniperoo.io`&#10;&#10;**Variable 2 : SNIPEROO_API_KEY**&#10;- Clé : `SNIPEROO_API_KEY`&#10;- Valeur : `&lt;votre-clé-api-valide&gt;`&#10;&#10;**Variable 3 : SNIPEROO_WS_URL**&#10;- Clé : `SNIPEROO_WS_URL`&#10;- Valeur : `wss://ws.sniperoo.io`&#10;&#10;### Étape 3 : Sauvegardez et Déployez&#10;1. Cliquez sur **Save Changes**&#10;2. Attendez que Railway redéploie l'application&#10;3. Vérifiez que le déploiement est ✅ **Successful**&#10;&#10;##  Test Post-Configuration&#10;&#10;### Test 1 : Vérifier que les variables sont chargées&#10;&#10;Vérifiez les logs de votre application API sur Railway :&#10;&#10;```&#10;✅ [SniperooService] SniperooService initialized with API URL: https://api.sniperoo.io&#10;```&#10;&#10;### Test 2 : Créer un portefeuille via l'API&#10;&#10;```bash&#10;curl -X POST https://api-production-5998.up.railway.app/api/wallets \&#10;  -H &quot;Authorization: Bearer &lt;votre-token-jwt&gt;&quot; \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;name&quot;: &quot;Test Wallet&quot;}'&#10;```&#10;&#10;**Réponse attendue :**&#10;```json&#10;{&#10;  &quot;id&quot;: &quot;wallet_123...&quot;,&#10;  &quot;name&quot;: &quot;Test Wallet&quot;,&#10;  &quot;publicKey&quot;: &quot;So1...&quot;,&#10;  &quot;balance&quot;: 0,&#10;  &quot;isActive&quot;: true,&#10;  &quot;createdAt&quot;: &quot;2025-11-09T10:30:00Z&quot;&#10;}&#10;```&#10;&#10;### Test 3 : Via l'interface Web&#10;&#10;1. Ouvrez https://web-production-1beed.up.railway.app/dashboard/wallets&#10;2. Cliquez sur **Create Wallet**&#10;3. Entrez un nom&#10;4. Cliquez sur **Create Wallet**&#10;5. ✅ Le portefeuille devrait être créé sans erreur 404&#10;&#10;##  Dépannage&#10;&#10;### Erreur 404 : Request failed with status code 404&#10;&#10;**Cause** : L'une de ces variables n'est pas configurée correctement :&#10;- `SNIPEROO_API_URL` est incorrect&#10;- `SNIPEROO_API_KEY` est vide ou invalide&#10;- L'endpoint n'existe pas&#10;&#10;**Solution** :&#10;1. Vérifiez que `SNIPEROO_API_KEY` n'est pas `your-sniperoo-api-key-here`&#10;2. Contactez Sniperoo pour obtenir une clé valide&#10;3. Redéployez l'application&#10;&#10;### Erreur 401 : Unauthorized&#10;&#10;**Cause** : La clé API est invalide ou expirée&#10;&#10;**Solution** :&#10;1. Générez une nouvelle clé API depuis le dashboard Sniperoo&#10;2. Mettez à jour la variable `SNIPEROO_API_KEY`&#10;3. Redéployez l'application&#10;&#10;### Service ne démarre pas&#10;&#10;**Cause** : Les variables d'environnement ne sont pas chargées&#10;&#10;**Solution** :&#10;1. Vérifiez que toutes les variables sont bien dans l'onglet **Variables** de Railway&#10;2. Cliquez sur **Redeploy**&#10;3. Attendez que le service redémarre&#10;&#10;##  Variables de Votre Fichier .env Local (Development)&#10;&#10;Pour le développement local, mettez à jour votre fichier `.env` :&#10;&#10;```bash&#10;# apps/api/.env&#10;DATABASE_URL=&quot;postgresql://postgres:postgres@localhost:5432/solana_trading_crm_dev&quot;&#10;REDIS_HOST=localhost&#10;REDIS_PORT=6379&#10;JWT_SECRET=your-super-secret-jwt-key-change-this-in-production&#10;JWT_REFRESH_SECRET=your-super-secret-refresh-key-change-this-in-production&#10;JWT_EXPIRES_IN=15m&#10;JWT_REFRESH_EXPIRES_IN=7d&#10;PORT=3001&#10;FRONTEND_URL=http://localhost:3000&#10;&#10;# Sniperoo Configuration&#10;SNIPEROO_API_URL=https://api.sniperoo.io&#10;SNIPEROO_API_KEY=your-valid-sniperoo-api-key-here&#10;SNIPEROO_WS_URL=wss://ws.sniperoo.io&#10;```&#10;&#10;## ✅ Résumé&#10;&#10;1. ✅ Obtenez une clé API valide depuis Sniperoo&#10;2. ✅ Configurez les 3 variables sur Railway&#10;3. ✅ Redéployez votre application&#10;4. ✅ Testez la création de portefeuille&#10;&#10;La création de portefeuilles devrait maintenant fonctionner ! &#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SNIPEROO_API_COMPLIANCE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SNIPEROO_API_COMPLIANCE.md" />
              <option name="updatedContent" value="# Sniperoo API Compliance Verification&#10;&#10;## Document de Vérification&#10;Date: 2025-11-09&#10;URL Documentation: https://sniperoo.redocly.app/swagger/wallet/paths/~1user~1wallets/post&#10;&#10;## Conformité des Endpoints&#10;&#10;### ✅ Endpoints Wallet&#10;&#10;| Méthode | Endpoint | Statut | Notes |&#10;|---------|----------|--------|-------|&#10;| POST | `/user/wallets` | ✅ Conforme | Crée un nouveau portefeuille |&#10;| POST | `/user/wallets/import` | ✅ Conforme | Importe un portefeuille existant |&#10;| GET | `/user/wallets` | ✅ Conforme | Liste tous les portefeuilles |&#10;| GET | `/user/wallets/{walletId}` | ✅ Conforme | Récupère un portefeuille spécifique |&#10;| DELETE | `/user/wallets/{walletId}` | ✅ Conforme | Supprime un portefeuille |&#10;| GET | `/user/wallets/{walletId}/balance` | ✅ Conforme | Récupère le solde d'un portefeuille |&#10;&#10;### ✅ Endpoints Orders/Trades&#10;&#10;| Méthode | Endpoint | Statut | Notes |&#10;|---------|----------|--------|-------|&#10;| POST | `/user/orders/buy` | ✅ Conforme | Crée un ordre d'achat |&#10;| POST | `/user/orders/sell` | ✅ Conforme | Crée un ordre de vente |&#10;| GET | `/user/orders` | ✅ Conforme | Liste les ordres |&#10;| GET | `/user/positions` | ✅ Conforme | Liste les positions |&#10;| POST | `/user/positions/{positionId}/close` | ✅ Conforme | Ferme une position |&#10;&#10;## Format de Requête - POST /user/wallets&#10;&#10;### Requête Attendue (selon documentation)&#10;```json&#10;{&#10;  &quot;name&quot;: &quot;string&quot;&#10;}&#10;```&#10;&#10;### Implémentation Actuelle&#10;```typescript&#10;const response = await this.client.post&lt;SniperooCreateWalletResponse&gt;('/user/wallets', {&#10;  name,&#10;});&#10;```&#10;&#10;✅ **Conforme**: Le format de la requête correspond exactement à la documentation.&#10;&#10;## Format de Réponse - POST /user/wallets&#10;&#10;### Réponse Attendue (selon documentation)&#10;```typescript&#10;{&#10;  wallet: {&#10;    id: string;&#10;    publicKey: string;&#10;    balance: number;&#10;    createdAt?: string;&#10;  };&#10;  privateKey: string;&#10;}&#10;```&#10;&#10;### Type Défini dans le Code&#10;```typescript&#10;export interface SniperooCreateWalletResponse {&#10;  wallet: SniperooWallet;&#10;  privateKey: string;&#10;}&#10;&#10;export interface SniperooWallet {&#10;  id: string;&#10;  publicKey: string;&#10;  balance: number;&#10;  createdAt?: string;&#10;}&#10;```&#10;&#10;✅ **Conforme**: La structure de la réponse correspond à la documentation.&#10;&#10;## Authentification&#10;&#10;### En-têtes d'Authentification&#10;```typescript&#10;headers: {&#10;  'Content-Type': 'application/json',&#10;  Authorization: `Bearer ${this.apiKey}`,&#10;}&#10;```&#10;&#10;✅ **Conforme**: Utilise Bearer token comme spécifié par Sniperoo.&#10;&#10;## Configuration&#10;&#10;### Variables d'Environnement Requises&#10;```&#10;SNIPEROO_API_URL=https://api.sniperoo.io&#10;SNIPEROO_API_KEY=&lt;your-valid-api-key&gt;&#10;SNIPEROO_WS_URL=wss://ws.sniperoo.io&#10;```&#10;&#10;### Fallbacks Définis&#10;```typescript&#10;this.apiUrl = this.configService.get&lt;string&gt;('SNIPEROO_API_URL') || 'https://api.sniperoo.io';&#10;this.apiKey = this.configService.get&lt;string&gt;('SNIPEROO_API_KEY') || '';&#10;```&#10;&#10;✅ **Conforme**: Les URL par défaut correspondent à l'API Sniperoo officielle.&#10;&#10;## Gestion des Erreurs&#10;&#10;### Retry Logic&#10;- ✅ MaxRetries: 3 tentatives&#10;- ✅ InitialDelay: 1000ms&#10;- ✅ BackoffMultiplier: 2x (1000ms → 2000ms → 4000ms)&#10;- ✅ Timeout: 30000ms (30 secondes)&#10;&#10;### Logging&#10;- ✅ Logs de succès: &quot;Wallet created: {id}&quot;&#10;- ✅ Logs d'erreur: Message d'erreur de Sniperoo&#10;- ✅ Logs d'avertissement: Tentatives de retry&#10;&#10;## Conclusion&#10;&#10;✅ **Le code respecte COMPLÈTEMENT la documentation Sniperoo**&#10;&#10;Tous les endpoints utilisent les chemins corrects `/user/...` et les formats de requête/réponse sont conformes à la documentation officielle.&#10;&#10;### Si vous recevez toujours une erreur 404, cela signifie :&#10;&#10;1. ❌ La clé API `SNIPEROO_API_KEY` n'est pas configurée ou est invalide&#10;2. ❌ L'URL `SNIPEROO_API_URL` n'est pas correcte&#10;3. ❌ Votre compte Sniperoo n'a pas accès à ces endpoints&#10;&#10;### Actions Recommandées :&#10;&#10;1. Vérifiez que `SNIPEROO_API_KEY` est une clé valide depuis votre dashboard Sniperoo&#10;2. Confirmez que votre plan Sniperoo inclut l'accès à la création de portefeuilles&#10;3. Testez l'endpoint manuellement avec curl:&#10;   ```bash&#10;   curl -X POST https://api.sniperoo.io/user/wallets \&#10;     -H &quot;Authorization: Bearer $SNIPEROO_API_KEY&quot; \&#10;     -H &quot;Content-Type: application/json&quot; \&#10;     -d '{&quot;name&quot;:&quot;Test Wallet&quot;}'&#10;   ```&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/src/helius/helius.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/src/helius/helius.service.ts" />
              <option name="updatedContent" value="import { Injectable, Logger } from '@nestjs/common';&#10;import { ConfigService } from '@nestjs/config';&#10;import axios from 'axios';&#10;import { RaydiumPool, TokenInfo } from '../trading/dto/trading.types';&#10;&#10;@Injectable()&#10;export class HeliusService {&#10;  private readonly logger = new Logger(HeliusService.name);&#10;  private readonly heliusApiKey: string;&#10;  private readonly heliusApiUrl = 'https://api.helius.xyz/v0';&#10;  private ws: WebSocket;&#10;  private reconnectAttempts = 0;&#10;  private maxReconnectAttempts = 5;&#10;&#10;  constructor(private configService: ConfigService) {&#10;    this.heliusApiKey = this.configService.get&lt;string&gt;('HELIUS_API_KEY') || '';&#10;  }&#10;&#10;  async subscribeNewPools(callback: (pool: RaydiumPool) =&gt; void): Promise&lt;void&gt; {&#10;    try {&#10;      const wsUrl = `wss://api.helius.xyz/?api-key=${this.heliusApiKey}`;&#10;      this.ws = new WebSocket(wsUrl);&#10;&#10;      this.ws.onopen = () =&gt; {&#10;        this.logger.log('Connected to Helius WebSocket');&#10;        this.reconnectAttempts = 0;&#10;&#10;        const subscription = {&#10;          jsonrpc: '2.0',&#10;          id: 1,&#10;          method: 'transactionSubscribe',&#10;          params: [&#10;            {&#10;              failed: false,&#10;              accountInclude: ['675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1xf'],&#10;            },&#10;            {&#10;              encoding: 'jsonParsed',&#10;              transactionDetails: 'full',&#10;              showRewards: false,&#10;            },&#10;          ],&#10;        };&#10;&#10;        this.ws.send(JSON.stringify(subscription));&#10;      };&#10;&#10;      this.ws.onmessage = (event) =&gt; {&#10;        try {&#10;          const data = JSON.parse(event.data);&#10;          if (data.result?.transaction) {&#10;            const pool = this.parseRaydiumPool(data.result.transaction);&#10;            if (pool) {&#10;              callback(pool);&#10;            }&#10;          }&#10;        } catch (error) {&#10;          this.logger.error('Error parsing WebSocket message:', error);&#10;        }&#10;      };&#10;&#10;      this.ws.onerror = (error) =&gt; {&#10;        this.logger.error('WebSocket error:', error);&#10;      };&#10;&#10;      this.ws.onclose = () =&gt; {&#10;        this.logger.warn('WebSocket closed, attempting to reconnect...');&#10;        if (this.reconnectAttempts &lt; this.maxReconnectAttempts) {&#10;          this.reconnectAttempts++;&#10;          setTimeout(() =&gt; this.subscribeNewPools(callback), 5000);&#10;        }&#10;      };&#10;    } catch (error) {&#10;      this.logger.error('Error subscribing to new pools:', error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  async getTokenInfo(tokenAddress: string): Promise&lt;TokenInfo&gt; {&#10;    try {&#10;      const response = await axios.get(&#10;        `${this.heliusApiUrl}/token-metadata?address=${tokenAddress}&amp;api-key=${this.heliusApiKey}`,&#10;      );&#10;&#10;      const data = response.data;&#10;      return {&#10;        address: tokenAddress,&#10;        symbol: data.symbol || 'UNKNOWN',&#10;        name: data.name || 'Unknown Token',&#10;        decimals: data.decimals || 6,&#10;        supply: data.supply || 0,&#10;        holders: data.holders || 0,&#10;        liquidityLocked: 0,&#10;        top10Holdings: 0,&#10;      };&#10;    } catch (error) {&#10;      this.logger.error(`Error fetching token info for ${tokenAddress}:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  async getTokenPrice(tokenAddress: string): Promise&lt;number&gt; {&#10;    try {&#10;      const response = await axios.get(&#10;        `${this.heliusApiUrl}/token-price?address=${tokenAddress}&amp;api-key=${this.heliusApiKey}`,&#10;      );&#10;&#10;      return response.data.price || 0;&#10;    } catch (error) {&#10;      this.logger.error(`Error fetching token price for ${tokenAddress}:`, error);&#10;      return 0;&#10;    }&#10;  }&#10;&#10;  private parseRaydiumPool(transaction: any): RaydiumPool | null {&#10;    try {&#10;      const instructions = transaction.message?.instructions || [];&#10;&#10;      for (const instruction of instructions) {&#10;        if (instruction.programId === '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1xf') {&#10;          const parsed = instruction.parsed;&#10;          if (parsed?.type === 'initializePool') {&#10;            return {&#10;              address: parsed.info?.pool || '',&#10;              tokenAddress: parsed.info?.tokenMint || '',&#10;              tokenSymbol: 'NEW',&#10;              tokenName: 'New Token',&#10;              liquidity: 0,&#10;              volume24h: 0,&#10;              priceUsd: 0,&#10;              createdAt: new Date(),&#10;            };&#10;          }&#10;        }&#10;      }&#10;&#10;      return null;&#10;    } catch (error) {&#10;      this.logger.error('Error parsing Raydium pool:', error);&#10;      return null;&#10;    }&#10;  }&#10;&#10;  closeConnection(): void {&#10;    if (this.ws) {&#10;      this.ws.close();&#10;    }&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/src/trading/executors/order-executor.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/src/trading/executors/order-executor.service.ts" />
              <option name="originalContent" value="import { Injectable, Logger, BadRequestException } from '@nestjs/common';&#10;import { PrismaService } from '../../prisma/prisma.service';&#10;import { SniperooService } from '../../sniperoo/sniperoo.service';&#10;import { OrderResult } from '../dto/trading.types';&#10;import { ExecuteTradeDto } from '../dto/execute-trade.dto';&#10;&#10;@Injectable()&#10;export class OrderExecutorService {&#10;  private readonly logger = new Logger(OrderExecutorService.name);&#10;  private readonly maxTradesPerMinute = 10;&#10;  private tradeTimestamps: Map&lt;string, number[]&gt; = new Map();&#10;&#10;  constructor(&#10;    private prisma: PrismaService,&#10;    private sniperooService: SniperooService,&#10;  ) {}&#10;&#10;  async executeBuy(dto: ExecuteTradeDto): Promise&lt;OrderResult&gt; {&#10;    this.logger.log(`Executing buy order: ${JSON.stringify(dto)}`);&#10;&#10;    await this.checkRateLimit(dto.walletId);&#10;    await this.validateWalletBalance(dto.walletId, dto.amount);&#10;&#10;    try {&#10;      const wallet = await this.prisma.wallet.findUnique({&#10;        where: { id: dto.walletId },&#10;      });&#10;&#10;      if (!wallet) {&#10;        throw new BadRequestException('Wallet not found');&#10;      }&#10;&#10;      const result = await this.sniperooService.buy({&#10;        walletId: wallet.sniperooWalletId,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        slippage: dto.slippage,&#10;      });&#10;&#10;      const transaction = await this.prisma.transaction.create({&#10;        data: {&#10;          walletId: dto.walletId,&#10;          type: 'BUY',&#10;          signature: result.signature,&#10;          tokenAddress: dto.tokenAddress,&#10;          amount: dto.amount,&#10;          price: result.price,&#10;          totalValue: result.amount,&#10;          fee: result.fee,&#10;          status: 'CONFIRMED',&#10;          blockTime: new Date(),&#10;        },&#10;      });&#10;&#10;      this.recordTrade(dto.walletId);&#10;&#10;      return {&#10;        signature: result.signature,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        price: result.price,&#10;        quantity: result.quantity,&#10;        fee: result.fee,&#10;        timestamp: new Date(),&#10;      };&#10;    } catch (error) {&#10;      this.logger.error(`Error executing buy order:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  async executeSell(dto: ExecuteTradeDto): Promise&lt;OrderResult&gt; {&#10;    this.logger.log(`Executing sell order: ${JSON.stringify(dto)}`);&#10;&#10;    await this.checkRateLimit(dto.walletId);&#10;&#10;    try {&#10;      const wallet = await this.prisma.wallet.findUnique({&#10;        where: { id: dto.walletId },&#10;      });&#10;&#10;      if (!wallet) {&#10;        throw new BadRequestException('Wallet not found');&#10;      }&#10;&#10;      const result = await this.sniperooService.executeSell({&#10;        walletId: wallet.sniperooWalletId,&#10;        tokenAddress: dto.tokenAddress,&#10;        quantity: dto.amount,&#10;        slippage: dto.slippage,&#10;      });&#10;&#10;      const transaction = await this.prisma.transaction.create({&#10;        data: {&#10;          walletId: dto.walletId,&#10;          type: 'SELL',&#10;          signature: result.signature,&#10;          tokenAddress: dto.tokenAddress,&#10;          amount: dto.amount,&#10;          price: result.price,&#10;          totalValue: result.amount,&#10;          fee: result.fee,&#10;          status: 'CONFIRMED',&#10;          blockTime: new Date(),&#10;        },&#10;      });&#10;&#10;      this.recordTrade(dto.walletId);&#10;&#10;      return {&#10;        signature: result.signature,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        price: result.price,&#10;        quantity: result.quantity,&#10;        fee: result.fee,&#10;        timestamp: new Date(),&#10;      };&#10;    } catch (error) {&#10;      this.logger.error(`Error executing sell order:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async checkRateLimit(walletId: string): Promise&lt;void&gt; {&#10;    const now = Date.now();&#10;    const oneMinuteAgo = now - 60000;&#10;&#10;    const timestamps = this.tradeTimestamps.get(walletId) || [];&#10;    const recentTrades = timestamps.filter((ts) =&gt; ts &gt; oneMinuteAgo);&#10;&#10;    if (recentTrades.length &gt;= this.maxTradesPerMinute) {&#10;      throw new BadRequestException(&#10;        `Rate limit exceeded: maximum ${this.maxTradesPerMinute} trades per minute`,&#10;      );&#10;    }&#10;  }&#10;&#10;  private recordTrade(walletId: string): void {&#10;    const now = Date.now();&#10;    const timestamps = this.tradeTimestamps.get(walletId) || [];&#10;    timestamps.push(now);&#10;    this.tradeTimestamps.set(walletId, timestamps);&#10;  }&#10;&#10;  private async validateWalletBalance(&#10;    walletId: string,&#10;    requiredAmount: number,&#10;  ): Promise&lt;void&gt; {&#10;    const wallet = await this.prisma.wallet.findUnique({&#10;      where: { id: walletId },&#10;    });&#10;&#10;    if (!wallet || wallet.balance &lt; requiredAmount) {&#10;      throw new BadRequestException(&#10;        `Insufficient balance. Required: ${requiredAmount}, Available: ${wallet?.balance || 0}`,&#10;      );&#10;    }&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { Injectable, Logger, BadRequestException } from '@nestjs/common';&#10;import { PrismaService } from '../../prisma/prisma.service';&#10;import { SniperooService } from '../../sniperoo/sniperoo.service';&#10;import { OrderResult } from '../dto/trading.types';&#10;import { ExecuteTradeDto } from '../dto/execute-trade.dto';&#10;&#10;@Injectable()&#10;export class OrderExecutorService {&#10;  private readonly logger = new Logger(OrderExecutorService.name);&#10;  private readonly maxTradesPerMinute = 10;&#10;  private tradeTimestamps: Map&lt;string, number[]&gt; = new Map();&#10;&#10;  constructor(&#10;    private prisma: PrismaService,&#10;    private sniperooService: SniperooService,&#10;  ) {}&#10;&#10;  async executeBuy(dto: ExecuteTradeDto): Promise&lt;OrderResult&gt; {&#10;    this.logger.log(`Executing buy order: ${JSON.stringify(dto)}`);&#10;&#10;    await this.checkRateLimit(dto.walletId);&#10;    await this.validateWalletBalance(dto.walletId, dto.amount);&#10;&#10;    try {&#10;      const wallet = await this.prisma.wallet.findUnique({&#10;        where: { id: dto.walletId },&#10;      });&#10;&#10;      if (!wallet) {&#10;        throw new BadRequestException('Wallet not found');&#10;      }&#10;&#10;      const result = await this.sniperooService.buy({&#10;        walletId: wallet.sniperooWalletId,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        slippage: dto.slippage,&#10;      });&#10;&#10;      const transaction = await this.prisma.transaction.create({&#10;        data: {&#10;          walletId: dto.walletId,&#10;          type: 'BUY',&#10;          signature: result.signature,&#10;          tokenAddress: dto.tokenAddress,&#10;          amount: dto.amount,&#10;          price: result.price || 0,&#10;          totalValue: result.amount || 0,&#10;          fee: result.fee || 0,&#10;          status: 'CONFIRMED',&#10;          blockTime: new Date(),&#10;        },&#10;      });&#10;&#10;      this.recordTrade(dto.walletId);&#10;&#10;      return {&#10;        signature: result.signature,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        price: result.price || 0,&#10;        quantity: result.quantity || 0,&#10;        fee: result.fee || 0,&#10;        timestamp: new Date(),&#10;      };&#10;    } catch (error) {&#10;      this.logger.error(`Error executing buy order:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  async executeSell(dto: ExecuteTradeDto): Promise&lt;OrderResult&gt; {&#10;    this.logger.log(`Executing sell order: ${JSON.stringify(dto)}`);&#10;&#10;    await this.checkRateLimit(dto.walletId);&#10;&#10;    try {&#10;      const wallet = await this.prisma.wallet.findUnique({&#10;        where: { id: dto.walletId },&#10;      });&#10;&#10;      if (!wallet) {&#10;        throw new BadRequestException('Wallet not found');&#10;      }&#10;&#10;      const result = await this.sniperooService.sell({&#10;        walletId: wallet.sniperooWalletId,&#10;        tokenAddress: dto.tokenAddress,&#10;        quantity: dto.amount,&#10;        slippage: dto.slippage,&#10;      });&#10;&#10;      const transaction = await this.prisma.transaction.create({&#10;        data: {&#10;          walletId: dto.walletId,&#10;          type: 'SELL',&#10;          signature: result.signature,&#10;          tokenAddress: dto.tokenAddress,&#10;          amount: dto.amount,&#10;          price: result.price || 0,&#10;          totalValue: result.amount || 0,&#10;          fee: result.fee || 0,&#10;          status: 'CONFIRMED',&#10;          blockTime: new Date(),&#10;        },&#10;      });&#10;&#10;      this.recordTrade(dto.walletId);&#10;&#10;      return {&#10;        signature: result.signature,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        price: result.price || 0,&#10;        quantity: result.quantity || 0,&#10;        fee: result.fee || 0,&#10;        timestamp: new Date(),&#10;      };&#10;    } catch (error) {&#10;      this.logger.error(`Error executing sell order:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async checkRateLimit(walletId: string): Promise&lt;void&gt; {&#10;    const now = Date.now();&#10;    const oneMinuteAgo = now - 60000;&#10;&#10;    const timestamps = this.tradeTimestamps.get(walletId) || [];&#10;    const recentTrades = timestamps.filter((ts) =&gt; ts &gt; oneMinuteAgo);&#10;&#10;    if (recentTrades.length &gt;= this.maxTradesPerMinute) {&#10;      throw new BadRequestException(&#10;        `Rate limit exceeded: maximum ${this.maxTradesPerMinute} trades per minute`,&#10;      );&#10;    }&#10;  }&#10;&#10;  private recordTrade(walletId: string): void {&#10;    const now = Date.now();&#10;    const timestamps = this.tradeTimestamps.get(walletId) || [];&#10;    timestamps.push(now);&#10;    this.tradeTimestamps.set(walletId, timestamps);&#10;  }&#10;&#10;  private async validateWalletBalance(&#10;    walletId: string,&#10;    requiredAmount: number,&#10;  ): Promise&lt;void&gt; {&#10;    const wallet = await this.prisma.wallet.findUnique({&#10;      where: { id: walletId },&#10;    });&#10;&#10;    if (!wallet || wallet.balance &lt; requiredAmount) {&#10;      throw new BadRequestException(&#10;        `Insufficient balance. Required: ${requiredAmount}, Available: ${wallet?.balance || 0}`,&#10;      );&#10;    }&#10;  }&#10;}&#10;&#10;      const transaction = await this.prisma.transaction.create({&#10;        data: {&#10;          walletId: dto.walletId,&#10;          type: 'SELL',&#10;          signature: result.signature,&#10;          tokenAddress: dto.tokenAddress,&#10;          amount: dto.amount,&#10;          price: result.price,&#10;          totalValue: result.amount,&#10;          fee: result.fee,&#10;          status: 'CONFIRMED',&#10;          blockTime: new Date(),&#10;        },&#10;      });&#10;&#10;      this.recordTrade(dto.walletId);&#10;&#10;      return {&#10;        signature: result.signature,&#10;        tokenAddress: dto.tokenAddress,&#10;        amount: dto.amount,&#10;        price: result.price,&#10;        quantity: result.quantity,&#10;        fee: result.fee,&#10;        timestamp: new Date(),&#10;      };&#10;    } catch (error) {&#10;      this.logger.error(`Error executing sell order:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async checkRateLimit(walletId: string): Promise&lt;void&gt; {&#10;    const now = Date.now();&#10;    const oneMinuteAgo = now - 60000;&#10;&#10;    const timestamps = this.tradeTimestamps.get(walletId) || [];&#10;    const recentTrades = timestamps.filter((ts) =&gt; ts &gt; oneMinuteAgo);&#10;&#10;    if (recentTrades.length &gt;= this.maxTradesPerMinute) {&#10;      throw new BadRequestException(&#10;        `Rate limit exceeded: maximum ${this.maxTradesPerMinute} trades per minute`,&#10;      );&#10;    }&#10;  }&#10;&#10;  private recordTrade(walletId: string): void {&#10;    const now = Date.now();&#10;    const timestamps = this.tradeTimestamps.get(walletId) || [];&#10;    timestamps.push(now);&#10;    this.tradeTimestamps.set(walletId, timestamps);&#10;  }&#10;&#10;  private async validateWalletBalance(&#10;    walletId: string,&#10;    requiredAmount: number,&#10;  ): Promise&lt;void&gt; {&#10;    const wallet = await this.prisma.wallet.findUnique({&#10;      where: { id: walletId },&#10;    });&#10;&#10;    if (!wallet || wallet.balance &lt; requiredAmount) {&#10;      throw new BadRequestException(&#10;        `Insufficient balance. Required: ${requiredAmount}, Available: ${wallet?.balance || 0}`,&#10;      );&#10;    }&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/src/trading/strategies/grid-selling.strategy.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/src/trading/strategies/grid-selling.strategy.ts" />
              <option name="originalContent" value="import { Injectable } from '@nestjs/common';&#10;import { BaseStrategy } from './base-strategy';&#10;import { GridSellingConfig } from '../dto/execute-trade.dto';&#10;import { PositionManagerService } from '../executors/position-manager.service';&#10;import { OrderExecutorService } from '../executors/order-executor.service';&#10;&#10;@Injectable()&#10;export class GridSellingStrategy extends BaseStrategy {&#10;  constructor(&#10;    private positionManager: PositionManagerService,&#10;    private orderExecutor: OrderExecutorService,&#10;  ) {&#10;    super();&#10;  }&#10;&#10;  async execute(strategyId: string, config: GridSellingConfig): Promise&lt;void&gt; {&#10;    this.logger.log(`Starting GridSellingStrategy for ${strategyId}`);&#10;&#10;    try {&#10;      if (!config.positionId) {&#10;        throw new Error('Position ID is required for grid selling strategy');&#10;      }&#10;&#10;      const position = await this.positionManager.getPosition(config.positionId);&#10;      if (!position) {&#10;        throw new Error(`Position ${config.positionId} not found`);&#10;      }&#10;&#10;      const startPrice = position.entryPrice;&#10;&#10;      for (const target of config.targets) {&#10;        const targetPrice = startPrice * target.priceMultiplier;&#10;        const sellQuantity = (position.quantity * target.sellPercent) / 100;&#10;&#10;        this.logger.log(&#10;          `Grid selling: waiting for price ${targetPrice} to sell ${sellQuantity} tokens`,&#10;        );&#10;&#10;        await this.waitForPriceTarget(&#10;          position.tokenAddress,&#10;          targetPrice,&#10;          async () =&gt; {&#10;            try {&#10;              const order = await this.orderExecutor.executeSell({&#10;                walletId: position.walletId,&#10;                tokenAddress: position.tokenAddress,&#10;                quantity: sellQuantity,&#10;                slippage: 2,&#10;                strategyId,&#10;              });&#10;&#10;              await this.positionManager.updatePosition(config.positionId, {&#10;                quantity: position.quantity - sellQuantity,&#10;              });&#10;&#10;              await this.logExecution(strategyId, 'success', {&#10;                positionId: config.positionId,&#10;                targetPrice,&#10;                sellQuantity,&#10;                order,&#10;              });&#10;&#10;              await this.notifyUser(strategyId, 'grid_sell_executed', {&#10;                tokenAddress: position.tokenAddress,&#10;                quantity: sellQuantity,&#10;                price: order.price,&#10;                pnl: (order.price - position.entryPrice) * sellQuantity,&#10;              });&#10;            } catch (error) {&#10;              this.logger.error(`Error executing grid sell:`, error);&#10;              await this.logExecution(strategyId, 'failed', error);&#10;            }&#10;          },&#10;        );&#10;      }&#10;    } catch (error) {&#10;      this.logger.error(`Error in GridSellingStrategy:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async waitForPriceTarget(&#10;    tokenAddress: string,&#10;    targetPrice: number,&#10;    callback: () =&gt; Promise&lt;void&gt;,&#10;  ): Promise&lt;void&gt; {&#10;    const checkInterval = 10000;&#10;    const maxWaitTime = 30 * 24 * 60 * 60 * 1000;&#10;    const startTime = Date.now();&#10;&#10;    const checkPrice = async () =&gt; {&#10;      try {&#10;        const currentPrice = await this.positionManager.getCurrentPrice(&#10;          tokenAddress,&#10;        );&#10;&#10;        if (currentPrice &gt;= targetPrice) {&#10;          await callback();&#10;          return;&#10;        }&#10;&#10;        if (Date.now() - startTime &lt; maxWaitTime) {&#10;          setTimeout(checkPrice, checkInterval);&#10;        } else {&#10;          this.logger.warn(&#10;            `Grid selling timeout for ${tokenAddress} at target ${targetPrice}`,&#10;          );&#10;        }&#10;      } catch (error) {&#10;        this.logger.error(`Error checking price for grid selling:`, error);&#10;        setTimeout(checkPrice, checkInterval);&#10;      }&#10;    };&#10;&#10;    checkPrice();&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Injectable } from '@nestjs/common';&#10;import { BaseStrategy } from './base-strategy';&#10;import { GridSellingConfig } from '../dto/execute-trade.dto';&#10;import { PositionManagerService } from '../executors/position-manager.service';&#10;import { OrderExecutorService } from '../executors/order-executor.service';&#10;&#10;@Injectable()&#10;export class GridSellingStrategy extends BaseStrategy {&#10;  constructor(&#10;    private positionManager: PositionManagerService,&#10;    private orderExecutor: OrderExecutorService,&#10;  ) {&#10;    super();&#10;  }&#10;&#10;  async execute(strategyId: string, config: GridSellingConfig): Promise&lt;void&gt; {&#10;    this.logger.log(`Starting GridSellingStrategy for ${strategyId}`);&#10;&#10;    try {&#10;      if (!config.positionId) {&#10;        throw new Error('Position ID is required for grid selling strategy');&#10;      }&#10;&#10;      const position = await this.positionManager.getPosition(config.positionId);&#10;      if (!position) {&#10;        throw new Error(`Position ${config.positionId} not found`);&#10;      }&#10;&#10;      const startPrice = position.entryPrice;&#10;&#10;      for (const target of config.targets) {&#10;        const targetPrice = startPrice * target.priceMultiplier;&#10;        const sellQuantity = (position.quantity * target.sellPercent) / 100;&#10;&#10;        this.logger.log(&#10;          `Grid selling: waiting for price ${targetPrice} to sell ${sellQuantity} tokens`,&#10;        );&#10;&#10;        await this.waitForPriceTarget(&#10;          position.tokenAddress,&#10;          targetPrice,&#10;          async () =&gt; {&#10;            try {&#10;              const order = await this.orderExecutor.executeSell({&#10;                walletId: position.walletId,&#10;                tokenAddress: position.tokenAddress,&#10;                amount: sellQuantity,&#10;                slippage: 2,&#10;                strategyId: strategyId!,&#10;              });&#10;&#10;              await this.positionManager.updatePosition(config.positionId, {&#10;                quantity: position.quantity - sellQuantity,&#10;              });&#10;&#10;              await this.logExecution(strategyId, 'success', {&#10;                positionId: config.positionId,&#10;                targetPrice,&#10;                sellQuantity,&#10;                order,&#10;              });&#10;&#10;              await this.notifyUser(strategyId, 'grid_sell_executed', {&#10;                tokenAddress: position.tokenAddress,&#10;                quantity: sellQuantity,&#10;                price: order.price,&#10;                pnl: (order.price - position.entryPrice) * sellQuantity,&#10;              });&#10;            } catch (error) {&#10;              this.logger.error(`Error executing grid sell:`, error);&#10;              await this.logExecution(strategyId, 'failed', error);&#10;            }&#10;          },&#10;        );&#10;      }&#10;    } catch (error) {&#10;      this.logger.error(`Error in GridSellingStrategy:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async waitForPriceTarget(&#10;    tokenAddress: string,&#10;    targetPrice: number,&#10;    callback: () =&gt; Promise&lt;void&gt;,&#10;  ): Promise&lt;void&gt; {&#10;    const checkInterval = 10000;&#10;    const maxWaitTime = 30 * 24 * 60 * 60 * 1000;&#10;    const startTime = Date.now();&#10;&#10;    const checkPrice = async () =&gt; {&#10;      try {&#10;        const currentPrice = await this.positionManager.getCurrentPrice(&#10;          tokenAddress,&#10;        );&#10;&#10;        if (currentPrice &gt;= targetPrice) {&#10;          await callback();&#10;          return;&#10;        }&#10;&#10;        if (Date.now() - startTime &lt; maxWaitTime) {&#10;          setTimeout(checkPrice, checkInterval);&#10;        } else {&#10;          this.logger.warn(&#10;            `Grid selling timeout for ${tokenAddress} at target ${targetPrice}`,&#10;          );&#10;        }&#10;      } catch (error) {&#10;        this.logger.error(`Error checking price for grid selling:`, error);&#10;        setTimeout(checkPrice, checkInterval);&#10;      }&#10;    };&#10;&#10;    checkPrice();&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/src/trading/strategies/trailing-stop.strategy.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/src/trading/strategies/trailing-stop.strategy.ts" />
              <option name="originalContent" value="import { Injectable } from '@nestjs/common';&#10;import { BaseStrategy } from './base-strategy';&#10;import { TrailingStopConfig } from '../dto/execute-trade.dto';&#10;import { PositionManagerService } from '../executors/position-manager.service';&#10;import { OrderExecutorService } from '../executors/order-executor.service';&#10;&#10;@Injectable()&#10;export class TrailingStopStrategy extends BaseStrategy {&#10;  private ath: Map&lt;string, number&gt; = new Map();&#10;  private stopLossPrice: Map&lt;string, number&gt; = new Map();&#10;&#10;  constructor(&#10;    private positionManager: PositionManagerService,&#10;    private orderExecutor: OrderExecutorService,&#10;  ) {&#10;    super();&#10;  }&#10;&#10;  async execute(strategyId: string, config: TrailingStopConfig): Promise&lt;void&gt; {&#10;    this.logger.log(`Starting TrailingStopStrategy for ${strategyId}`);&#10;&#10;    try {&#10;      const position = await this.positionManager.getPosition(config.positionId);&#10;      if (!position) {&#10;        throw new Error(`Position ${config.positionId} not found`);&#10;      }&#10;&#10;      const activationPrice =&#10;        config.activationMultiplier &amp;&amp; config.activationMultiplier &gt; 1&#10;          ? position.entryPrice * config.activationMultiplier&#10;          : position.entryPrice;&#10;&#10;      this.ath.set(config.positionId, activationPrice);&#10;      this.stopLossPrice.set(&#10;        config.positionId,&#10;        activationPrice * (1 - config.trailPercent / 100),&#10;      );&#10;&#10;      await this.monitorTrailingStop(strategyId, config, position);&#10;    } catch (error) {&#10;      this.logger.error(`Error in TrailingStopStrategy:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async monitorTrailingStop(&#10;    strategyId: string,&#10;    config: TrailingStopConfig,&#10;    position: any,&#10;  ): Promise&lt;void&gt; {&#10;    const checkInterval = 5000;&#10;    const maxWaitTime = 30 * 24 * 60 * 60 * 1000;&#10;    const startTime = Date.now();&#10;&#10;    const checkStop = async () =&gt; {&#10;      try {&#10;        const currentPrice = await this.positionManager.getCurrentPrice(&#10;          position.tokenAddress,&#10;        );&#10;&#10;        const currentAth = this.ath.get(config.positionId) || position.entryPrice;&#10;        const currentStopLoss =&#10;          this.stopLossPrice.get(config.positionId) ||&#10;          currentAth * (1 - config.trailPercent / 100);&#10;&#10;        if (currentPrice &gt; currentAth) {&#10;          this.ath.set(config.positionId, currentPrice);&#10;          this.stopLossPrice.set(&#10;            config.positionId,&#10;            currentPrice * (1 - config.trailPercent / 100),&#10;          );&#10;          this.logger.log(&#10;            `ATH updated to ${currentPrice}, new stop loss at ${currentPrice * (1 - config.trailPercent / 100)}`,&#10;          );&#10;        }&#10;&#10;        if (currentPrice &lt;= currentStopLoss) {&#10;          this.logger.log(&#10;            `Stop loss triggered at ${currentPrice}, selling position`,&#10;          );&#10;&#10;          const order = await this.orderExecutor.executeSell({&#10;            walletId: position.walletId,&#10;            tokenAddress: position.tokenAddress,&#10;            quantity: position.quantity,&#10;            slippage: 2,&#10;            strategyId,&#10;          });&#10;&#10;          await this.positionManager.closePosition(config.positionId, currentPrice);&#10;&#10;          await this.logExecution(strategyId, 'success', {&#10;            positionId: config.positionId,&#10;            stopLossPrice: currentStopLoss,&#10;            exitPrice: currentPrice,&#10;            order,&#10;          });&#10;&#10;          await this.notifyUser(strategyId, 'stop_loss_triggered', {&#10;            tokenAddress: position.tokenAddress,&#10;            exitPrice: currentPrice,&#10;            pnl: (currentPrice - position.entryPrice) * position.quantity,&#10;          });&#10;&#10;          return;&#10;        }&#10;&#10;        if (Date.now() - startTime &lt; maxWaitTime) {&#10;          setTimeout(checkStop, checkInterval);&#10;        }&#10;      } catch (error) {&#10;        this.logger.error(`Error monitoring trailing stop:`, error);&#10;        setTimeout(checkStop, checkInterval);&#10;      }&#10;    };&#10;&#10;    checkStop();&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Injectable } from '@nestjs/common';&#10;import { BaseStrategy } from './base-strategy';&#10;import { TrailingStopConfig } from '../dto/execute-trade.dto';&#10;import { PositionManagerService } from '../executors/position-manager.service';&#10;import { OrderExecutorService } from '../executors/order-executor.service';&#10;&#10;@Injectable()&#10;export class TrailingStopStrategy extends BaseStrategy {&#10;  private ath: Map&lt;string, number&gt; = new Map();&#10;  private stopLossPrice: Map&lt;string, number&gt; = new Map();&#10;&#10;  constructor(&#10;    private positionManager: PositionManagerService,&#10;    private orderExecutor: OrderExecutorService,&#10;  ) {&#10;    super();&#10;  }&#10;&#10;  async execute(strategyId: string, config: TrailingStopConfig): Promise&lt;void&gt; {&#10;    this.logger.log(`Starting TrailingStopStrategy for ${strategyId}`);&#10;&#10;    try {&#10;      const position = await this.positionManager.getPosition(config.positionId);&#10;      if (!position) {&#10;        throw new Error(`Position ${config.positionId} not found`);&#10;      }&#10;&#10;      const activationPrice =&#10;        config.activationMultiplier &amp;&amp; config.activationMultiplier &gt; 1&#10;          ? position.entryPrice * config.activationMultiplier&#10;          : position.entryPrice;&#10;&#10;      this.ath.set(config.positionId, activationPrice);&#10;      this.stopLossPrice.set(&#10;        config.positionId,&#10;        activationPrice * (1 - config.trailPercent / 100),&#10;      );&#10;&#10;      await this.monitorTrailingStop(strategyId, config, position);&#10;    } catch (error) {&#10;      this.logger.error(`Error in TrailingStopStrategy:`, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  private async monitorTrailingStop(&#10;    strategyId: string,&#10;    config: TrailingStopConfig,&#10;    position: any,&#10;  ): Promise&lt;void&gt; {&#10;    const checkInterval = 5000;&#10;    const maxWaitTime = 30 * 24 * 60 * 60 * 1000;&#10;    const startTime = Date.now();&#10;&#10;    const checkStop = async () =&gt; {&#10;      try {&#10;        const currentPrice = await this.positionManager.getCurrentPrice(&#10;          position.tokenAddress,&#10;        );&#10;&#10;        const currentAth = this.ath.get(config.positionId) || position.entryPrice;&#10;        const currentStopLoss =&#10;          this.stopLossPrice.get(config.positionId) ||&#10;          currentAth * (1 - config.trailPercent / 100);&#10;&#10;        if (currentPrice &gt; currentAth) {&#10;          this.ath.set(config.positionId, currentPrice);&#10;          this.stopLossPrice.set(&#10;            config.positionId,&#10;            currentPrice * (1 - config.trailPercent / 100),&#10;          );&#10;          this.logger.log(&#10;            `ATH updated to ${currentPrice}, new stop loss at ${currentPrice * (1 - config.trailPercent / 100)}`,&#10;          );&#10;        }&#10;&#10;        if (currentPrice &lt;= currentStopLoss) {&#10;          this.logger.log(&#10;            `Stop loss triggered at ${currentPrice}, selling position`,&#10;          );&#10;&#10;          const order = await this.orderExecutor.executeSell({&#10;            walletId: position.walletId,&#10;            tokenAddress: position.tokenAddress,&#10;            amount: position.quantity,&#10;            slippage: 2,&#10;            strategyId: strategyId!,&#10;          });&#10;&#10;          await this.positionManager.closePosition(config.positionId, currentPrice);&#10;&#10;          await this.logExecution(strategyId, 'success', {&#10;            positionId: config.positionId,&#10;            stopLossPrice: currentStopLoss,&#10;            exitPrice: currentPrice,&#10;            order,&#10;          });&#10;&#10;          await this.notifyUser(strategyId, 'stop_loss_triggered', {&#10;            tokenAddress: position.tokenAddress,&#10;            exitPrice: currentPrice,&#10;            pnl: (currentPrice - position.entryPrice) * position.quantity,&#10;          });&#10;&#10;          return;&#10;        }&#10;&#10;        if (Date.now() - startTime &lt; maxWaitTime) {&#10;          setTimeout(checkStop, checkInterval);&#10;        }&#10;      } catch (error) {&#10;        this.logger.error(`Error monitoring trailing stop:`, error);&#10;        setTimeout(checkStop, checkInterval);&#10;      }&#10;    };&#10;&#10;    checkStop();&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/.env.local">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/.env.local" />
              <option name="updatedContent" value="NEXT_PUBLIC_API_URL=https://api-production-5998.up.railway.app&#10;NEXT_PUBLIC_WS_URL=wss://api-production-5998.up.railway.app&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/strategies/strategy-form.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/strategies/strategy-form.tsx" />
              <option name="updatedContent" value="'use client';&#10;&#10;import { useState } from 'react';&#10;import { useForm } from 'react-hook-form';&#10;import { zodResolver } from '@hookform/resolvers/zod';&#10;import * as z from 'zod';&#10;import { Button } from '@/components/ui/button';&#10;import {&#10;  Form,&#10;  FormControl,&#10;  FormDescription,&#10;  FormField,&#10;  FormItem,&#10;  FormLabel,&#10;  FormMessage,&#10;} from '@/components/ui/form';&#10;import { Input } from '@/components/ui/input';&#10;import { Textarea } from '@/components/ui/textarea';&#10;import {&#10;  Select,&#10;  SelectContent,&#10;  SelectItem,&#10;  SelectTrigger,&#10;  SelectValue,&#10;} from '@/components/ui/select';&#10;import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';&#10;import { AutoBuyConfig } from './strategy-config/auto-buy-config';&#10;import { GridSellingConfig } from './strategy-config/grid-selling-config';&#10;import { TrailingStopConfig } from './strategy-config/trailing-stop-config';&#10;import { DCAConfig } from './strategy-config/dca-config';&#10;&#10;const strategyFormSchema = z.object({&#10;  name: z.string().min(1, 'Strategy name is required'),&#10;  description: z.string().optional(),&#10;  type: z.enum(['AUTO_BUY_NEW_POOLS', 'GRID_SELLING', 'TRAILING_STOP', 'DCA']),&#10;});&#10;&#10;type StrategyFormValues = z.infer&lt;typeof strategyFormSchema&gt;;&#10;&#10;interface StrategyFormProps {&#10;  onSubmit: (data: any) =&gt; Promise&lt;void&gt;;&#10;  isLoading?: boolean;&#10;  defaultValues?: any;&#10;}&#10;&#10;export function StrategyForm({ onSubmit, isLoading, defaultValues }: StrategyFormProps) {&#10;  const [selectedType, setSelectedType] = useState&lt;string&gt;(defaultValues?.type || '');&#10;  const [configData, setConfigData] = useState&lt;any&gt;(defaultValues?.params || {});&#10;&#10;  const form = useForm&lt;StrategyFormValues&gt;({&#10;    resolver: zodResolver(strategyFormSchema),&#10;    defaultValues: {&#10;      name: defaultValues?.name || '',&#10;      description: defaultValues?.description || '',&#10;      type: defaultValues?.type || 'AUTO_BUY_NEW_POOLS',&#10;    },&#10;  });&#10;&#10;  const handleSubmit = async (values: StrategyFormValues) =&gt; {&#10;    const payload = {&#10;      name: values.name,&#10;      description: values.description,&#10;      config: {&#10;        type: values.type,&#10;        params: configData,&#10;      },&#10;    };&#10;&#10;    await onSubmit(payload);&#10;  };&#10;&#10;  return (&#10;    &lt;Form {...form}&gt;&#10;      &lt;form onSubmit={form.handleSubmit(handleSubmit)} className=&quot;space-y-6&quot;&gt;&#10;        &lt;Card&gt;&#10;          &lt;CardHeader&gt;&#10;            &lt;CardTitle&gt;Strategy Details&lt;/CardTitle&gt;&#10;            &lt;CardDescription&gt;Basic information about your trading strategy&lt;/CardDescription&gt;&#10;          &lt;/CardHeader&gt;&#10;          &lt;CardContent className=&quot;space-y-4&quot;&gt;&#10;            &lt;FormField&#10;              control={form.control}&#10;              name=&quot;name&quot;&#10;              render={({ field }: { field: any }) =&gt; (&#10;                &lt;FormItem&gt;&#10;                  &lt;FormLabel&gt;Strategy Name&lt;/FormLabel&gt;&#10;                  &lt;FormControl&gt;&#10;                    &lt;Input placeholder=&quot;e.g., My First Bot&quot; {...field} /&gt;&#10;                  &lt;/FormControl&gt;&#10;                  &lt;FormMessage /&gt;&#10;                &lt;/FormItem&gt;&#10;              )}&#10;            /&gt;&#10;&#10;            &lt;FormField&#10;              control={form.control}&#10;              name=&quot;description&quot;&#10;              render={({ field }: { field: any }) =&gt; (&#10;                &lt;FormItem&gt;&#10;                  &lt;FormLabel&gt;Description (Optional)&lt;/FormLabel&gt;&#10;                  &lt;FormControl&gt;&#10;                    &lt;Textarea placeholder=&quot;Describe your strategy...&quot; {...field} /&gt;&#10;                  &lt;/FormControl&gt;&#10;                  &lt;FormMessage /&gt;&#10;                &lt;/FormItem&gt;&#10;              )}&#10;            /&gt;&#10;&#10;            &lt;FormField&#10;              control={form.control}&#10;              name=&quot;type&quot;&#10;              render={({ field }: { field: any }) =&gt; (&#10;                &lt;FormItem&gt;&#10;                  &lt;FormLabel&gt;Strategy Type&lt;/FormLabel&gt;&#10;                  &lt;Select&#10;                    onValueChange={(value: string) =&gt; {&#10;                      field.onChange(value);&#10;                      setSelectedType(value);&#10;                      setConfigData({});&#10;                    }}&#10;                    defaultValue={field.value}&#10;                  &gt;&#10;                    &lt;FormControl&gt;&#10;                      &lt;SelectTrigger&gt;&#10;                        &lt;SelectValue placeholder=&quot;Select a strategy type&quot; /&gt;&#10;                      &lt;/SelectTrigger&gt;&#10;                    &lt;/FormControl&gt;&#10;                    &lt;SelectContent&gt;&#10;                      &lt;SelectItem value=&quot;AUTO_BUY_NEW_POOLS&quot;&gt;Auto-Buy New Pools&lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;GRID_SELLING&quot;&gt;Grid Selling&lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;TRAILING_STOP&quot;&gt;Trailing Stop-Loss&lt;/SelectItem&gt;&#10;                      &lt;SelectItem value=&quot;DCA&quot;&gt;Dollar Cost Averaging&lt;/SelectItem&gt;&#10;                    &lt;/SelectContent&gt;&#10;                  &lt;/Select&gt;&#10;                  &lt;FormMessage /&gt;&#10;                &lt;/FormItem&gt;&#10;              )}&#10;            /&gt;&#10;          &lt;/CardContent&gt;&#10;        &lt;/Card&gt;&#10;&#10;        {selectedType === 'AUTO_BUY_NEW_POOLS' &amp;&amp; (&#10;          &lt;AutoBuyConfig onConfigChange={setConfigData} defaultValues={configData} /&gt;&#10;        )}&#10;&#10;        {selectedType === 'GRID_SELLING' &amp;&amp; (&#10;          &lt;GridSellingConfig onConfigChange={setConfigData} defaultValues={configData} /&gt;&#10;        )}&#10;&#10;        {selectedType === 'TRAILING_STOP' &amp;&amp; (&#10;          &lt;TrailingStopConfig onConfigChange={setConfigData} defaultValues={configData} /&gt;&#10;        )}&#10;&#10;        {selectedType === 'DCA' &amp;&amp; (&#10;          &lt;DCAConfig onConfigChange={setConfigData} defaultValues={configData} /&gt;&#10;        )}&#10;&#10;        &lt;Button type=&quot;submit&quot; disabled={isLoading} className=&quot;w-full&quot;&gt;&#10;          {isLoading ? 'Creating...' : 'Create Strategy'}&#10;        &lt;/Button&gt;&#10;      &lt;/form&gt;&#10;    &lt;/Form&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/ui/badge.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/ui/badge.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;import { cva, type VariantProps } from &quot;class-variance-authority&quot;&#10;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;const badgeVariants = cva(&#10;  &quot;inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2&quot;,&#10;  {&#10;    variants: {&#10;      variant: {&#10;        default:&#10;          &quot;border-transparent bg-primary text-primary-foreground hover:bg-primary/80&quot;,&#10;        secondary:&#10;          &quot;border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80&quot;,&#10;        destructive:&#10;          &quot;border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80&quot;,&#10;        outline: &quot;text-foreground&quot;,&#10;      },&#10;    },&#10;    defaultVariants: {&#10;      variant: &quot;default&quot;,&#10;    },&#10;  }&#10;)&#10;&#10;export interface BadgeProps&#10;  extends React.HTMLAttributes&lt;HTMLDivElement&gt;,&#10;    VariantProps&lt;typeof badgeVariants&gt; {}&#10;&#10;function Badge({ className, variant, ...props }: BadgeProps) {&#10;  return (&#10;    &lt;div className={cn(badgeVariants({ variant }), className)} {...props} /&gt;&#10;  )&#10;}&#10;&#10;export { Badge, badgeVariants }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/ui/dropdown-menu.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/ui/dropdown-menu.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;import * as DropdownMenuPrimitive from &quot;@radix-ui/react-dropdown-menu&quot;&#10;import { Check, ChevronRight, Circle } from &quot;lucide-react&quot;&#10;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;const DropdownMenu = DropdownMenuPrimitive.Root&#10;&#10;const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger&#10;&#10;const DropdownMenuGroup = DropdownMenuPrimitive.Group&#10;&#10;const DropdownMenuPortal = DropdownMenuPrimitive.Portal&#10;&#10;const DropdownMenuSub = DropdownMenuPrimitive.Sub&#10;&#10;const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup&#10;&#10;const DropdownMenuSubTrigger = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.SubTrigger&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.SubTrigger&gt; &amp; {&#10;    inset?: boolean&#10;  }&#10;&gt;(({ className, inset, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.SubTrigger&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm font-medium outline-none focus:bg-accent data-[state=open]:bg-accent&quot;,&#10;      inset &amp;&amp; &quot;pl-8&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  &gt;&#10;    {props.children}&#10;    &lt;ChevronRight className=&quot;ml-auto h-4 w-4&quot; /&gt;&#10;  &lt;/DropdownMenuPrimitive.SubTrigger&gt;&#10;))&#10;DropdownMenuSubTrigger.displayName =&#10;  DropdownMenuPrimitive.SubTrigger.displayName&#10;&#10;const DropdownMenuSubContent = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.SubContent&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.SubContent&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.SubContent&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  /&gt;&#10;))&#10;DropdownMenuSubContent.displayName =&#10;  DropdownMenuPrimitive.SubContent.displayName&#10;&#10;const DropdownMenuContent = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.Content&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Content&gt;&#10;&gt;(({ className, sideOffset = 4, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.Portal&gt;&#10;    &lt;DropdownMenuPrimitive.Content&#10;      ref={ref}&#10;      sideOffset={sideOffset}&#10;      className={cn(&#10;        &quot;min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,&#10;        className&#10;      )}&#10;      {...props}&#10;    /&gt;&#10;  &lt;/DropdownMenuPrimitive.Portal&gt;&#10;))&#10;DropdownMenuContent.displayName =&#10;  DropdownMenuPrimitive.Content.displayName&#10;&#10;const DropdownMenuItem = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.Item&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Item&gt; &amp; {&#10;    inset?: boolean&#10;  }&#10;&gt;(({ className, inset, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.Item&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,&#10;      inset &amp;&amp; &quot;pl-8&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  /&gt;&#10;))&#10;DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName&#10;&#10;const DropdownMenuCheckboxItem = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;&#10;&gt;(({ className, children, checked, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.CheckboxItem&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;relative flex cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,&#10;      className&#10;    )}&#10;    checked={checked}&#10;    {...props}&#10;  &gt;&#10;    &lt;span className=&quot;absolute left-2 flex h-3.5 w-3.5 items-center justify-center&quot;&gt;&#10;      &lt;DropdownMenuPrimitive.ItemIndicator&gt;&#10;        &lt;Check className=&quot;h-4 w-4&quot; /&gt;&#10;      &lt;/DropdownMenuPrimitive.ItemIndicator&gt;&#10;    &lt;/span&gt;&#10;    {children}&#10;  &lt;/DropdownMenuPrimitive.CheckboxItem&gt;&#10;))&#10;DropdownMenuCheckboxItem.displayName =&#10;  DropdownMenuPrimitive.CheckboxItem.displayName&#10;&#10;const DropdownMenuRadioItem = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.RadioItem&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.RadioItem&gt;&#10;&gt;(({ className, children, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.RadioItem&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;relative flex cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  &gt;&#10;    &lt;span className=&quot;absolute left-2 flex h-3.5 w-3.5 items-center justify-center&quot;&gt;&#10;      &lt;DropdownMenuPrimitive.ItemIndicator&gt;&#10;        &lt;Circle className=&quot;h-2 w-2 fill-current&quot; /&gt;&#10;      &lt;/DropdownMenuPrimitive.ItemIndicator&gt;&#10;    &lt;/span&gt;&#10;    {children}&#10;  &lt;/DropdownMenuPrimitive.RadioItem&gt;&#10;))&#10;DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName&#10;&#10;const DropdownMenuLabel = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.Label&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Label&gt; &amp; {&#10;    inset?: boolean&#10;  }&#10;&gt;(({ className, inset, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.Label&#10;    ref={ref}&#10;    className={cn(&quot;px-2 py-1.5 text-sm font-semibold&quot;, inset &amp;&amp; &quot;pl-8&quot;, className)}&#10;    {...props}&#10;  /&gt;&#10;))&#10;DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName&#10;&#10;const DropdownMenuSeparator = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof DropdownMenuPrimitive.Separator&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof DropdownMenuPrimitive.Separator&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;DropdownMenuPrimitive.Separator&#10;    ref={ref}&#10;    className={cn(&quot;-mx-1 my-1 h-px bg-muted&quot;, className)}&#10;    {...props}&#10;  /&gt;&#10;))&#10;DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName&#10;&#10;const DropdownMenuShortcut = ({&#10;  className,&#10;  ...props&#10;}: React.HTMLAttributes&lt;HTMLSpanElement&gt;) =&gt; (&#10;  &lt;span&#10;    className={cn(&quot;ml-auto text-xs tracking-widest text-muted-foreground&quot;, className)}&#10;    {...props}&#10;  /&gt;&#10;)&#10;DropdownMenuShortcut.displayName = &quot;DropdownMenuShortcut&quot;&#10;&#10;export {&#10;  DropdownMenu,&#10;  DropdownMenuTrigger,&#10;  DropdownMenuContent,&#10;  DropdownMenuItem,&#10;  DropdownMenuCheckboxItem,&#10;  DropdownMenuRadioItem,&#10;  DropdownMenuLabel,&#10;  DropdownMenuSeparator,&#10;  DropdownMenuShortcut,&#10;  DropdownMenuGroup,&#10;  DropdownMenuPortal,&#10;  DropdownMenuSub,&#10;  DropdownMenuSubContent,&#10;  DropdownMenuSubTrigger,&#10;  DropdownMenuRadioGroup,&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/ui/form.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/ui/form.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;import { Slot } from &quot;@radix-ui/react-slot&quot;&#10;import { Controller, ControllerProps, FieldPath, FieldValues, FormProvider, useFormContext } from &quot;react-hook-form&quot;&#10;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;const Form = FormProvider&#10;&#10;interface FormFieldContextValue&lt;&#10;  TFieldValues extends FieldValues = FieldValues,&#10;  TName extends FieldPath&lt;TFieldValues&gt; = FieldPath&lt;TFieldValues&gt;&#10;&gt; {&#10;  name: TName&#10;}&#10;&#10;const FormFieldContext = React.createContext&lt;FormFieldContextValue&gt;(&#10;  {} as FormFieldContextValue&#10;)&#10;&#10;const FormField = &lt;&#10;  TFieldValues extends FieldValues = FieldValues,&#10;  TName extends FieldPath&lt;TFieldValues&gt; = FieldPath&lt;TFieldValues&gt;&#10;&gt;({&#10;  ...props&#10;}: ControllerProps&lt;TFieldValues, TName&gt;) =&gt; (&#10;  &lt;FormFieldContext.Provider value={{ name: props.name }}&gt;&#10;    &lt;Controller {...props} /&gt;&#10;  &lt;/FormFieldContext.Provider&gt;&#10;)&#10;&#10;const useFormField = () =&gt; {&#10;  const fieldContext = React.useContext(FormFieldContext)&#10;  const itemContext = React.useContext(FormItemContext)&#10;  const { getFieldState, formState } = useFormContext()&#10;&#10;  const fieldState = getFieldState(fieldContext.name, formState)&#10;&#10;  if (!fieldContext) {&#10;    throw new Error(&quot;useFormField should be used within &lt;FormField&gt;&quot;)&#10;  }&#10;&#10;  const { id } = itemContext&#10;&#10;  return {&#10;    id,&#10;    name: fieldContext.name,&#10;    formItemId: `${id}-form-item`,&#10;    formDescriptionId: `${id}-form-item-description`,&#10;    formMessageId: `${id}-form-item-message`,&#10;    ...fieldState,&#10;  }&#10;}&#10;&#10;interface FormItemContextValue {&#10;  id: string&#10;}&#10;&#10;const FormItemContext = React.createContext&lt;FormItemContextValue&gt;(&#10;  {} as FormItemContextValue&#10;)&#10;&#10;const FormItem = React.forwardRef&lt;&#10;  HTMLDivElement,&#10;  React.HTMLAttributes&lt;HTMLDivElement&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; {&#10;  const id = React.useId()&#10;&#10;  return (&#10;    &lt;FormItemContext.Provider value={{ id }}&gt;&#10;      &lt;div ref={ref} className={cn(&quot;space-y-2&quot;, className)} {...props} /&gt;&#10;    &lt;/FormItemContext.Provider&gt;&#10;  )&#10;})&#10;FormItem.displayName = &quot;FormItem&quot;&#10;&#10;const FormLabel = React.forwardRef&lt;&#10;  React.ElementRef&lt;&quot;label&quot;&gt;,&#10;  React.LabelHTMLAttributes&lt;HTMLLabelElement&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; {&#10;  const { error, formItemId } = useFormField()&#10;&#10;  return (&#10;    &lt;label&#10;      ref={ref}&#10;      className={cn(&#10;        &quot;text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70&quot;,&#10;        error &amp;&amp; &quot;text-destructive&quot;,&#10;        className&#10;      )}&#10;      htmlFor={formItemId}&#10;      {...props}&#10;    /&gt;&#10;  )&#10;})&#10;FormLabel.displayName = &quot;FormLabel&quot;&#10;&#10;const FormControl = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof Slot&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof Slot&gt;&#10;&gt;(({ ...props }, ref) =&gt; {&#10;  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()&#10;&#10;  return (&#10;    &lt;Slot&#10;      ref={ref}&#10;      id={formItemId}&#10;      aria-describedby={&#10;        !error&#10;          ? `${formDescriptionId}`&#10;          : `${formDescriptionId} ${formMessageId}`&#10;      }&#10;      aria-invalid={!!error}&#10;      {...props}&#10;    /&gt;&#10;  )&#10;})&#10;FormControl.displayName = &quot;FormControl&quot;&#10;&#10;const FormDescription = React.forwardRef&lt;&#10;  HTMLParagraphElement,&#10;  React.HTMLAttributes&lt;HTMLParagraphElement&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; {&#10;  const { formDescriptionId } = useFormField()&#10;&#10;  return (&#10;    &lt;p&#10;      ref={ref}&#10;      id={formDescriptionId}&#10;      className={cn(&quot;text-sm text-muted-foreground&quot;, className)}&#10;      {...props}&#10;    /&gt;&#10;  )&#10;})&#10;FormDescription.displayName = &quot;FormDescription&quot;&#10;&#10;const FormMessage = React.forwardRef&lt;&#10;  HTMLParagraphElement,&#10;  React.HTMLAttributes&lt;HTMLParagraphElement&gt;&#10;&gt;(({ className, children, ...props }, ref) =&gt; {&#10;  const { error, formMessageId } = useFormField()&#10;  const body = error ? String(error?.message) : children&#10;&#10;  if (!body) {&#10;    return null&#10;  }&#10;&#10;  return (&#10;    &lt;p&#10;      ref={ref}&#10;      id={formMessageId}&#10;      className={cn(&quot;text-sm font-medium text-destructive&quot;, className)}&#10;      {...props}&#10;    &gt;&#10;      {body}&#10;    &lt;/p&gt;&#10;  )&#10;})&#10;FormMessage.displayName = &quot;FormMessage&quot;&#10;&#10;export {&#10;  useFormField,&#10;  Form,&#10;  FormItem,&#10;  FormLabel,&#10;  FormControl,&#10;  FormDescription,&#10;  FormMessage,&#10;  FormField,&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/ui/select.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/ui/select.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;import * as SelectPrimitive from &quot;@radix-ui/react-select&quot;&#10;import { Check, ChevronDown, ChevronUp } from &quot;lucide-react&quot;&#10;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;const Select = SelectPrimitive.Root&#10;&#10;const SelectGroup = SelectPrimitive.Group&#10;&#10;const SelectValue = SelectPrimitive.Value&#10;&#10;const SelectTrigger = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof SelectPrimitive.Trigger&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Trigger&gt;&#10;&gt;(({ className, children, ...props }, ref) =&gt; (&#10;  &lt;SelectPrimitive.Trigger&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&amp;&gt;span]:line-clamp-1&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  &gt;&#10;    {children}&#10;    &lt;SelectPrimitive.Icon asChild&gt;&#10;      &lt;ChevronDown className=&quot;h-4 w-4 opacity-50&quot; /&gt;&#10;    &lt;/SelectPrimitive.Icon&gt;&#10;  &lt;/SelectPrimitive.Trigger&gt;&#10;))&#10;SelectTrigger.displayName = SelectPrimitive.Trigger.displayName&#10;&#10;const SelectScrollUpButton = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof SelectPrimitive.ScrollUpButton&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.ScrollUpButton&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;SelectPrimitive.ScrollUpButton&#10;    ref={ref}&#10;    className={cn(&quot;flex cursor-pointer items-center justify-center py-1&quot;, className)}&#10;    {...props}&#10;  &gt;&#10;    &lt;ChevronUp className=&quot;h-4 w-4&quot; /&gt;&#10;  &lt;/SelectPrimitive.ScrollUpButton&gt;&#10;))&#10;SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName&#10;&#10;const SelectScrollDownButton = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof SelectPrimitive.ScrollDownButton&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.ScrollDownButton&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;SelectPrimitive.ScrollDownButton&#10;    ref={ref}&#10;    className={cn(&quot;flex cursor-pointer items-center justify-center py-1&quot;, className)}&#10;    {...props}&#10;  &gt;&#10;    &lt;ChevronDown className=&quot;h-4 w-4&quot; /&gt;&#10;  &lt;/SelectPrimitive.ScrollDownButton&gt;&#10;))&#10;SelectScrollDownButton.displayName =&#10;  SelectPrimitive.ScrollDownButton.displayName&#10;&#10;const SelectContent = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof SelectPrimitive.Content&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Content&gt;&#10;&gt;(({ className, children, position = &quot;popper&quot;, ...props }, ref) =&gt; (&#10;  &lt;SelectPrimitive.Portal&gt;&#10;    &lt;SelectPrimitive.Content&#10;      ref={ref}&#10;      className={cn(&#10;        &quot;relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2&quot;,&#10;        position === &quot;popper&quot; &amp;&amp;&#10;          &quot;data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1&quot;,&#10;        className&#10;      )}&#10;      position={position}&#10;      {...props}&#10;    &gt;&#10;      &lt;SelectScrollUpButton /&gt;&#10;      &lt;SelectPrimitive.Viewport&#10;        className={cn(&#10;          &quot;p-1&quot;,&#10;          position === &quot;popper&quot; &amp;&amp;&#10;            &quot;h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]&quot;&#10;        )}&#10;      &gt;&#10;        {children}&#10;      &lt;/SelectPrimitive.Viewport&gt;&#10;      &lt;SelectScrollDownButton /&gt;&#10;    &lt;/SelectPrimitive.Content&gt;&#10;  &lt;/SelectPrimitive.Portal&gt;&#10;))&#10;SelectContent.displayName = SelectPrimitive.Content.displayName&#10;&#10;const SelectItem = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof SelectPrimitive.Item&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Item&gt;&#10;&gt;(({ className, children, ...props }, ref) =&gt; (&#10;  &lt;SelectPrimitive.Item&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;relative flex w-full cursor-pointer select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  &gt;&#10;    &lt;span className=&quot;absolute left-2 flex h-3.5 w-3.5 items-center justify-center&quot;&gt;&#10;      &lt;SelectPrimitive.ItemIndicator&gt;&#10;        &lt;Check className=&quot;h-4 w-4&quot; /&gt;&#10;      &lt;/SelectPrimitive.ItemIndicator&gt;&#10;    &lt;/span&gt;&#10;&#10;    &lt;SelectPrimitive.ItemText&gt;{children}&lt;/SelectPrimitive.ItemText&gt;&#10;  &lt;/SelectPrimitive.Item&gt;&#10;))&#10;SelectItem.displayName = SelectPrimitive.Item.displayName&#10;&#10;const SelectSeparator = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof SelectPrimitive.Separator&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof SelectPrimitive.Separator&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;SelectPrimitive.Separator&#10;    ref={ref}&#10;    className={cn(&quot;-mx-1 my-1 h-px bg-muted&quot;, className)}&#10;    {...props}&#10;  /&gt;&#10;))&#10;SelectSeparator.displayName = SelectPrimitive.Separator.displayName&#10;&#10;export {&#10;  Select,&#10;  SelectGroup,&#10;  SelectValue,&#10;  SelectTrigger,&#10;  SelectContent,&#10;  SelectItem,&#10;  SelectSeparator,&#10;  SelectScrollUpButton,&#10;  SelectScrollDownButton,&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/ui/tabs.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/ui/tabs.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;import * as TabsPrimitive from &quot;@radix-ui/react-tabs&quot;&#10;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;const Tabs = TabsPrimitive.Root&#10;&#10;const TabsList = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof TabsPrimitive.List&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof TabsPrimitive.List&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;TabsPrimitive.List&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  /&gt;&#10;))&#10;TabsList.displayName = TabsPrimitive.List.displayName&#10;&#10;const TabsTrigger = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof TabsPrimitive.Trigger&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof TabsPrimitive.Trigger&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;TabsPrimitive.Trigger&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  /&gt;&#10;))&#10;TabsTrigger.displayName = TabsPrimitive.Trigger.displayName&#10;&#10;const TabsContent = React.forwardRef&lt;&#10;  React.ElementRef&lt;typeof TabsPrimitive.Content&gt;,&#10;  React.ComponentPropsWithoutRef&lt;typeof TabsPrimitive.Content&gt;&#10;&gt;(({ className, ...props }, ref) =&gt; (&#10;  &lt;TabsPrimitive.Content&#10;    ref={ref}&#10;    className={cn(&#10;      &quot;mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2&quot;,&#10;      className&#10;    )}&#10;    {...props}&#10;  /&gt;&#10;))&#10;TabsContent.displayName = TabsPrimitive.Content.displayName&#10;&#10;export { Tabs, TabsList, TabsTrigger, TabsContent }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/web/src/components/ui/textarea.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/web/src/components/ui/textarea.tsx" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;&#10;&#10;import { cn } from &quot;@/lib/utils&quot;&#10;&#10;export interface TextareaProps&#10;  extends React.TextareaHTMLAttributes&lt;HTMLTextAreaElement&gt; {}&#10;&#10;const Textarea = React.forwardRef&lt;HTMLTextAreaElement, TextareaProps&gt;(&#10;  ({ className, ...props }, ref) =&gt; (&#10;    &lt;textarea&#10;      className={cn(&#10;        &quot;flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50&quot;,&#10;        className&#10;      )}&#10;      ref={ref}&#10;      {...props}&#10;    /&gt;&#10;  )&#10;)&#10;Textarea.displayName = &quot;Textarea&quot;&#10;&#10;export { Textarea }&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>